/*! \mainpage MeshLab Filter Documentation

\section f0 Ambient Occlusion 

Compute ambient occlusions values; it takes a number of well distributed view direction and for point of the surface it computes how many time it is visible from these directions. This value is saved into quality and automatically mapped into a gray shade. The average direction is saved into an attribute named 'BentNormal'
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Occlusion mode: </TD> <TD><i> Occlusion may be calculated per-vertex or per-face, color and quality will be saved in the chosen component. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Directional Bias [0..1] </TD> <TD><i> The balance between a uniform and a directionally biased set of lighting direction<br>: - 0 means light came only uniformly from any direction<br> - 1 means that all the light cames from the specified cone of directions <br> - other values mix the two set of lighting directions  -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Requested views </TD> <TD><i> Number of different views uniformly placed around the mesh. More views means better accuracy at the cost of increased calculation time -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Lighting Direction </TD> <TD><i> Number of different views placed around the mesh. More views means better accuracy at the cost of increased calculation time -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Cone amplitude </TD> <TD><i> Number of different views uniformly placed around the mesh. More views means better accuracy at the cost of increased calculation time -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use GPU acceleration </TD> <TD><i> Only works for per-vertex AO. In order to use GPU-Mode, your hardware must support FBOs, FP32 Textures and Shaders. Normally increases the performance by a factor of 4x-5x -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Depth texture size(should be 2^n) </TD> <TD><i> Defines the depth texture size used to compute occlusion from each point of view. Higher values means better accuracy usually with low impact on performance -- </i></TD> </TR>
</TABLE>

\section f1 Set Mesh Camera 

This filter allows one to set a shot for the current mesh
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Shotf  </TD> <TD> New shot </TD> <TD><i> This filter allows one to set a shot for the current mesh. -- </i></TD> </TR>
</TABLE>

\section f2 Set Raster Camera 

This filter allows one to set a shot for the current mesh
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Shotf  </TD> <TD> New shot </TD> <TD><i> This filter allows one to set a shot for the current raster. -- </i></TD> </TR>
</TABLE>

\section f3 Vertex Quality from Camera 

Compute vertex quality using the camera definition, according to viewing angle or distance
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Depth </TD> <TD><i> Use depth as a factor. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> ViewAngle </TD> <TD><i> Use cosine of viewing angle as a factor. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Clipping </TD> <TD><i> clip values outside the viewport to zero. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> normalize </TD> <TD><i> if checked normalize all quality values in range [0..1] -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> map into color </TD> <TD><i> if checked map quality generated values into per-vertex color -- </i></TD> </TR>
</TABLE>

\section f4 Transform: Rotate Camera or set of cameras 

Rotate the camera, or all the cameras of the project. The selected raster is the reference if viewpoint rotation is selected.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Camera type </TD> <TD><i> Choose the camera to scale -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Rotation on: </TD> <TD><i> Choose a method -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Center of rotation: </TD> <TD><i> Choose a method -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Rotation Angle </TD> <TD><i> Angle of rotation (in <b>degree</b>). If snapping is enabled this value is rounded according to the snap value -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Custom axis </TD> <TD><i> This rotation axis is used only if the 'custom axis' option is chosen. -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Custom center </TD> <TD><i> This rotation center is used only if the 'custom point' option is chosen. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all active Raster layers </TD> <TD><i> Apply the same scaling to all the active Raster layers: it is taken into account only if 'Raster Camera' is selected -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all active Raster and visible Mesh layers </TD> <TD><i> Apply the same scaling to all the layers, including any visible 3D layer -- </i></TD> </TR>
</TABLE>

\section f5 Transform: Scale Camera or set of cameras 

Scale the camera, or all the cameras of the project. The selected raster is the reference if viewpoint scaling is selected.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Camera type </TD> <TD><i> Choose the camera to scale -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Center of scaling: </TD> <TD><i> Choose a method -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Custom center </TD> <TD><i> This scaling center is used only if the 'custom point' option is chosen. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Scale factor </TD> <TD><i> The scale factor that has to be applied to the camera -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all active Raster layers </TD> <TD><i> Apply the same scaling to all the active Raster layers: it is taken into account only if 'Raster Camera' is selected -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all active Raster and visible Mesh layers </TD> <TD><i> Apply the same scaling to all the layers, including any visible 3D layer -- </i></TD> </TR>
</TABLE>

\section f6 Transform: Translate Camera or set of cameras 

Translate the camera, or all the cameras of the project.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Camera type </TD> <TD><i> Choose the camera to scale -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> X Axis </TD> <TD><i> Absolute translation amount along the X axis -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Y Axis </TD> <TD><i> Absolute translation amount along the Y axis -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Z Axis </TD> <TD><i> Absolute translation amount along the Z axis -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> translate viewpoint position to the origin </TD> <TD><i> If selected, the camera viewpoint is translated to the origin -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all active Raster layers </TD> <TD><i> Apply the same scaling to all the active Raster layers: it is taken into account only if 'Raster Camera' is selected -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all active Raster and Mesh layers </TD> <TD><i> Apply the same scaling to all the layers, including any visible 3D layer -- </i></TD> </TR>
</TABLE>

\section f7 Transform the camera extrinsics, or all the cameras of the project. 

Transform the camera extrinsics, or all the cameras of the project.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Matrix44f  </TD> <TD>  </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Camera type </TD> <TD><i> Choose the camera to scale -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Matrix semantic </TD> <TD><i> What the matrix is used for -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all active Raster layers </TD> <TD><i> Apply the same scaling to all the active Raster layers: it is taken into account only if 'Raster Camera' is selected -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all active Raster and visible Mesh layers </TD> <TD><i> Apply the same scaling to all the layers, including any visible 3D layer -- </i></TD> </TR>
</TABLE>

\section f8 Re-Orient vertex normals using cameras 

Reorient vertex normals using cameras. For this  filter to work the mesh needs to have the attribute 'correspondences' which is only created when loading Bundler files (.out projects)
<H2> Parameters </h2>
No parameters.<br>
\section f9 Surface Reconstruction: Ball Pivoting 

Given a point cloud with normals it reconstructs a surface using the <b>Ball Pivoting Algorithm</b>.Starting with a seed triangle, the BPA algorithm  pivots a ball of the given radius around the already formed edgesuntil it touches another point, forming another triangle. The process continues until all reachable edges have been tried.This surface reconstruction algorithm uses the existing points without creating new ones. Works better with uniformly sampled point clouds. If needed first perform a poisson disk subsampling of the point cloud. <br>Bernardini F., Mittleman J., Rushmeier H., Silva C., Taubin G.<br><b>The ball-pivoting algorithm for surface reconstruction.</b><br>IEEE TVCG 1999
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Pivoting Ball radius (0 autoguess) </TD> <TD><i> The radius of the ball pivoting (rolling) over the set of points. Gaps that are larger than the ball radius will not be filled; similarly the small pits that are smaller than the ball radius will be filled. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Clustering radius (% of ball radius) </TD> <TD><i> To avoid the creation of too small triangles, if a vertex is found too close to a previous one, it is clustered/merged with it. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Angle Threshold (degrees) </TD> <TD><i> If we encounter a crease angle that is too large we should stop the ball rolling -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Delete initial set of faces </TD> <TD><i> if true all the initial faces of the mesh are deleted and the whole surface is rebuilt from scratch. Otherwise the current faces are used as a starting point. Useful if you run the algorithm multiple times with an increasing ball radius. -- </i></TD> </TR>
</TABLE>

\section f10 Remove Vertices wrt Quality 

Delete all the vertices with a quality lower smaller than the specified constant
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Delete all vertices with quality under: </TD> <TD><i>  -- </i></TD> </TR>
</TABLE>

\section f11 Remove Isolated pieces (wrt Face Num.) 

Delete isolated connected components composed by a limited number of triangles
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Enter minimum conn. comp size: </TD> <TD><i> Delete all the connected components (floating pieces) composed by a number of triangles smaller than the specified one -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Remove unfreferenced vertices </TD> <TD><i> if true, the unreferenced vertices remaining after the face deletion are removed. -- </i></TD> </TR>
</TABLE>

\section f12 Remove Isolated pieces (wrt Diameter) 

Delete isolated connected components whose diameter is smaller than the specified constant
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Enter max diameter of isolated pieces </TD> <TD><i> Delete all the connected components (floating pieces) with a diameter smaller than the specified one -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Remove unfreferenced vertices </TD> <TD><i> if true, the unreferenced vertices remaining after the face deletion are removed. -- </i></TD> </TR>
</TABLE>

\section f13 Remove T-Vertices by Edge Flip 

Delete t-vertices by flipping the opposite edge on the degenerate face if the triangulation quality improves
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Ratio </TD> <TD><i> Detects faces where the base/height ratio is lower than this value -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Iterate until convergence </TD> <TD><i> Iterates the algorithm until it reaches convergence -- </i></TD> </TR>
</TABLE>

\section f14 Remove T-Vertices by Edge Collapse 

Delete t-vertices from the mesh by collapsing the shortest of the incident edges
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Ratio </TD> <TD><i> Detects faces where the base/height ratio is lower than this value -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Iterate until convergence </TD> <TD><i> Iterates the algorithm until it reaches convergence -- </i></TD> </TR>
</TABLE>

\section f15 Snap Mismatched Borders 

Try to snap together adjacent borders that are slightly mismatched.<br>This situation can happen on badly triangulated adjacent patches defined by high order surfaces.<br>For each border vertex the filter snap it onto the closest boundary edge only if it is closest of <i>edge_length*threshold</i>. When vertex is snapped the corresponding face is split and a new vertex is created.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Edge Distance Ratio </TD> <TD><i> Collapse edge when the edge / distance ratio is greater than this value. E.g. for default value 1000 two straight border edges are collapsed if the central vertex dist from the straight line composed by the two edges less than a 1/1000 of the sum of the edges length. Larger values enforce that only vertices very close to the line are removed. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> UnifyVertices </TD> <TD><i> if true the snap vertices are weld together. -- </i></TD> </TR>
</TABLE>

\section f16 Remove Duplicate Faces 

Delete all the duplicate faces. Two faces are considered equal if they are composed by the same set of vertices, regardless of the order of the vertices.
<H2> Parameters </h2>
No parameters.<br>
\section f17 Remove Isolated Folded Faces by Edge Flip 

Delete all the single folded faces. A face is considered folded if its normal is opposite to all the adjacent faces. It is removed by flipping it against the face f adjacent along the edge e such that the vertex opposite to e fall inside f
<H2> Parameters </h2>
No parameters.<br>
\section f18 Repair non Manifold Edges by removing faces 

For each non Manifold edge it iteratively deletes the smallest area face until it becomes 2-Manifold.
<H2> Parameters </h2>
No parameters.<br>
\section f19 Repair non Manifold Edges by splitting vertices 

Remove all non manifold edges splitting vertices. Each non manifold edges chain will become a border
<H2> Parameters </h2>
No parameters.<br>
\section f20 Repair non Manifold Vertices by splitting 

Split non Manifold vertices until it becomes 2-Manifold.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Vertex Displacement Ratio </TD> <TD><i> When a vertex is split it is moved along the average vector going from its position to the baricyenter of the FF connected faces sharing it -- </i></TD> </TR>
</TABLE>

\section f21 Remove Unreferenced Vertices 

Check for every vertex on the mesh: if it is NOT referenced by a face, removes it
<H2> Parameters </h2>
No parameters.<br>
\section f22 Remove Duplicate Vertices 

Check for every vertex on the mesh: if there are two vertices with same coordinates they are merged into a single one.
<H2> Parameters </h2>
No parameters.<br>
\section f23 Remove Zero Area Faces 

Remove null faces (the one with area equal to zero)
<H2> Parameters </h2>
No parameters.<br>
\section f24 Merge Close Vertices 

Merge together all the vertices that are nearer than the specified threshold. Like a unify duplicated vertices but with some tolerance.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Merging distance </TD> <TD><i> All the vertices that closer than this threshold are merged together. Use very small values, default values is 1/10000 of bounding box diagonal.  -- </i></TD> </TR>
</TABLE>

\section f25 Merge Wedge Texture Coord 

Merge together per-wedge texture coords that are very close. Used to correct apparent texture seams that can arise from numerical approximations when saving in ascii formats.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Merging Threshold </TD> <TD><i> All the per-wedge texture coords that are on the same vertex and are distant less then the given threshold are merged together. It can be used to remove the fake texture seams that arise from error. Distance is in texture space (the default, 1e-4, corresponds to one texel on a 10kx10x texture)  -- </i></TD> </TR>
</TABLE>

\section f26 Compact faces 

Compact all the faces that have been deleted and put them to the end of the vector
<H2> Parameters </h2>
No parameters.<br>
\section f27 Compact vertices 

Compact all the vertices that have been deleted and put them to the end of the vector
<H2> Parameters </h2>
No parameters.<br>
\section f28 Project current raster color to current mesh 

Color information from the current raster is perspective-projected on the current mesh
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Use depth for projection </TD> <TD><i> If true, depth is used to restrict projection on visible faces -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> depth threshold </TD> <TD><i> threshold value for depth buffer projection (shadow buffer) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If true, projection is only done for selected vertices -- </i></TD> </TR>
<TR><TD> \c Color  </TD> <TD> Color for unprojected areas </TD> <TD><i> Areas that cannot be projected willb e filled using this color. If R=0 G=0 B=0 A=0 old color is preserved -- </i></TD> </TR>
</TABLE>

\section f29 Project active rasters color to current mesh 

Color information from all the active rasters is perspective-projected on the current mesh using basic weighting
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> depth threshold </TD> <TD><i> threshold value for depth buffer projection (shadow buffer) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If true, projection is only done for selected vertices -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use angle weight </TD> <TD><i> If true, color contribution is weighted by pixel view angle -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use distance weight </TD> <TD><i> If true, color contribution is weighted by pixel view distance -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use image borders weight </TD> <TD><i> If true, color contribution is weighted by pixel distance from image boundaries -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use depth discontinuities weight </TD> <TD><i> If true, color contribution is weighted by pixel distance from depth discontinuities (external and internal silhouettes) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use image alpha weight </TD> <TD><i> If true, alpha channel of the image is used as additional weight. In this way it is possible to mask-out parts of the images that should not be projected on the mesh. Please note this is not a transparency effect, but just influences the weigthing between different images -- </i></TD> </TR>
<TR><TD> \c Color  </TD> <TD> Color for unprojected areas </TD> <TD><i> Areas that cannot be projected willb e filled using this color. If R=0 G=0 B=0 A=0 old color is preserved -- </i></TD> </TR>
</TABLE>

\section f30 Project active rasters color to current mesh, filling the texture 

Color information from all the active rasters is perspective-projected on the current mesh, filling the texture, using basic weighting
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> Texture file </TD> <TD><i> The texture file to be created -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> pixel size of texture image </TD> <TD><i> pixel size of texture image, the image will be a square tsize X tsize, most applications do require that tsize is a power of 2 -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> fill atlas gaps </TD> <TD><i> If true, unfilled areas of the mesh are interpolated, to avoid visible seams while mipmapping -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> depth threshold </TD> <TD><i> threshold value for depth buffer projection (shadow buffer) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If true, projection is only done for selected vertices -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use angle weight </TD> <TD><i> If true, color contribution is weighted by pixel view angle -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use distance weight </TD> <TD><i> If true, color contribution is weighted by pixel view distance -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use image borders weight </TD> <TD><i> If true, color contribution is weighted by pixel distance from image boundaries -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use depth discontinuities weight </TD> <TD><i> If true, color contribution is weighted by pixel distance from depth discontinuities (external and internal silhouettes) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> use image alpha weight </TD> <TD><i> If true, alpha channel of the image is used as additional weight. In this way it is possible to mask-out parts of the images that should not be projected on the mesh. Please note this is not a transparency effect, but just influences the weigthing between different images -- </i></TD> </TR>
</TABLE>

\section f31 Vertex Color Filling 

Fills the color of the vertices of the mesh with a color chosen by the user.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Color  </TD> <TD> Color: </TD> <TD><i> Sets the color to apply to vertices. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f32 Vertex Color Invert 

Inverts the colors of the vertices of the mesh.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f33 Vertex Color Thresholding 

Colors the vertices of the mesh using two colors according to a lightness threshold (on the original color).
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Color  </TD> <TD> Color 1: </TD> <TD><i> Sets the color to apply below the threshold. -- </i></TD> </TR>
<TR><TD> \c Color  </TD> <TD> Color 2: </TD> <TD><i> Sets the color to apply above the threshold. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Threshold: </TD> <TD><i> Vertices with color above the lightness threshold becomes Color 2, the others Color 1. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f34 Vertex Color Brightness Contrast Gamma 

Change the color the vertices of the mesh adjusting brightness, contrast and gamma.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> Brightness: </TD> <TD><i> Sets the amount of brightness that will be added/subtracted to the colors.<br>Brightness = 255  ->  all white;<br>Brightness = -255  ->  all black; -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Contrast factor: </TD> <TD><i> Sets the amount of contrast of the mesh. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Gamma: </TD> <TD><i> Sets the values of the exponent gamma. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f35 Vertex Color Levels Adjustment 

The filter allows adjustment of color levels. It is a custom way to map an interval of color into another one. The user can set the input minimum and maximum levels, gamma and the output minimum and maximum levels (many tools call them respectively input black point, white point, gray point, output black point and white point).
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> Gamma: </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Min input level: </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Max input level: </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Min output level: </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Max output level: </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Red Channel: </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Green Channel: </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Blue Channel: </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> All visible layers </TD> <TD><i> if true, apply to all visible layers -- </i></TD> </TR>
</TABLE>

\section f36 Vertex Color Colourisation 

Allows the application of a color to the mesh. In spite of the Fill operation, the color is blended with the mesh according to a given intensity.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> Hue: </TD> <TD><i> Changes the hue of the mesh. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Saturation: </TD> <TD><i> Changes the saturation of the mesh. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Luminance: </TD> <TD><i> Changes the luminance of the mesh. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Blending: </TD> <TD><i> Sets the blending factor used in adding the new color to the existing one. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f37 Vertex Color Desaturation 

The filter desaturates the colors of the mesh. This provides a simple way to convert a mesh in gray tones. The user can choose the desaturation method to apply; they are based on Lightness, Luminosity and Average.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Desaturation method: </TD> <TD><i> Lightness is computed as (Max(r,g,b)+Min(r,g,b))/2<br>Luminosity is computed as 0.212*r + 0.715*g + 0.072*b<br>Average is computed as (r+g+b)/3 -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f38 Equalize Vertex Color 

The filter equalizes the colors histogram. It is a kind of automatic regulation of contrast; the colors histogram is expanded to fit all the range of colors.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Red Channel: </TD> <TD><i> Select the red channel. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Green Channel: </TD> <TD><i> Select the green channel. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Blue Channel: </TD> <TD><i> Select the blue channel.<br><br>If no channel is selected<br>filter works on Lightness. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f39 Vertex Color White Balance 

The filter provides a standard white balance transformation. It is done correcting the RGB channels with a factor such that, the brighter color in the mesh, that is supposed to be white, becomes really white.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Color  </TD> <TD> Unbalanced white:  </TD> <TD><i> The color that is supposed to be white. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f40 Perlin color 

Paints the mesh using PerlinColor function. The color assigned to vertices depends on their position in the space; it means that near vertices will be painted with similar colors.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Color  </TD> <TD> Color 1: </TD> <TD><i> Sets the first color to mix with Perlin Noise function. -- </i></TD> </TR>
<TR><TD> \c Color  </TD> <TD> Color 2: </TD> <TD><i> Sets the second color to mix with Perlin Noise function. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Frequency: </TD> <TD><i> Frequency of the Perlin Noise function, expressed as multiples of mesh bbox (frequency 10 means a noise period of bbox diagonal / 10). High frequencies produces many small splashes of colours, while low frequencies produces few big splashes. -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Offset </TD> <TD><i> This values is the XYZ frequency offset of the Noise function (offset 1 means 1 period shift). -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f41 Color noise 

Adds to the color the requested amount of bits of noise. Bits of noise are added independently for each RGB channel.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Noise bits: </TD> <TD><i> Bits of noise added to each RGB channel. Example: 3 noise bits adds three random offsets in the [-4,+4] interval to each RGB channels. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f42 PerMesh Color Scattering 

Assigns a random color to each visible mesh layer in the document. Colors change every time the filter is executed, but are always chosen so that they differ as much as possible.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Seed </TD> <TD><i> Random seed used to generate scattered colors. Zero means totally random (each time the filter is started it generates a different result) -- </i></TD> </TR>
</TABLE>

\section f43 Clamp Vertex Quality 

Clamp vertex quality values to a given range according to specific values or to percentiles
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Min </TD> <TD><i> The value that will be mapped with the lower end of the scale (blue) -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Max </TD> <TD><i> The value that will be mapped with the upper end of the scale (red) -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Percentile Crop [0..100] </TD> <TD><i> If not zero this value will be used for a percentile cropping of the quality values.<br> If this parameter is set to a value <i>P</i> then the two values <i>V_min,V_max</i> for which <i>P</i>% of the vertices have a quality <b>lower or greater than <i>V_min,V_max</i> are used as min/max values for clamping.<br><br> The automated percentile cropping is very useful for automatically discarding outliers. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Zero Symmetric </TD> <TD><i> If true the min max range will be enlarged to be symmetric (so that green is always Zero) -- </i></TD> </TR>
</TABLE>

\section f44 Saturate Vertex Quality 

Saturate vertex quality, so that for each vertex the gradient of the quality is lower than the given threshold value (in absolute value)
The saturation is done in a conservative way (quality is always decreased and never increased)
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Gradient Threshold </TD> <TD><i> The maximum value admitted for the quality gradient (in absolute value) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Update ColorMap </TD> <TD><i> if true the color ramp is computed again -- </i></TD> </TR>
</TABLE>

\section f45 Colorize by vertex Quality 

Color vertices depending on their quality field (manually equalized).
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Min </TD> <TD><i> The value that will be mapped with the lower end of the scale (blue) -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Max </TD> <TD><i> The value that will be mapped with the upper end of the scale (red) -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Percentile Crop [0..100] </TD> <TD><i> If not zero this value will be used for a percentile cropping of the quality values.<br> If this parameter is set to a value <i>P</i> then the two values <i>V_min,V_max</i> for which <i>P</i>% of the vertices have a quality <b>lower or greater than <i>V_min,V_max</i> are used as min/max values for clamping.<br><br> The automated percentile cropping is very useful for automatically discarding outliers. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Zero Symmetric </TD> <TD><i> If true the min max range will be enlarged to be symmetric (so that green is always Zero) -- </i></TD> </TR>
</TABLE>

\section f46 Colorize by face Quality 

Color faces depending on their quality field (manually equalized).
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Min </TD> <TD><i> The value that will be mapped with the lower end of the scale (blue) -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Max </TD> <TD><i> The value that will be mapped with the upper end of the scale (red) -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Percentile Crop [0..100] </TD> <TD><i> If not zero this value will be used for a percentile cropping of the quality values.<br> If this parameter is set to a value <i>P</i> then the two values <i>V_min,V_max</i> for which <i>P</i>% of the faces have a quality <b>lower or greater than <i>V_min,V_max</i> are used as min/max values for clamping.<br><br> The automated percentile cropping is very useful for automatically discarding outliers. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Zero Symmetric </TD> <TD><i> If true the min max range will be enlarged to be symmetric (so that green is always Zero) -- </i></TD> </TR>
</TABLE>

\section f47 Discrete Curvatures 

Colorize according to various discrete curvature computed as described in:<br>'<i>Discrete Differential-Geometry Operators for Triangulated 2-Manifolds</i>' <br>M. Meyer, M. Desbrun, P. Schroder, A. H. Barr
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Type: </TD> <TD><i> Choose the curvature value that you want transferred onto the scalar Quality.Mean (H) and Gaussian (K) curvature are computed according the technique described in the Desbrun et al. paper.<br>Absolute curvature is defined as |H|+|K| and RMS curvature as sqrt(4* H^2 - 2K) as explained in <br><i>Improved curvature estimationfor watershed segmentation of 3-dimensional meshes </i> by S. Pulla, A. Razdan, G. Farin.  -- </i></TD> </TR>
</TABLE>

\section f48 Per Face Quality according to Triangle shape and aspect ratio 

Compute a quality and colorize faces depending on triangle shape:<ol><li>area/max side of triangle<li>ratio inradius/circumradius (radii of incircle and circumcircle)<li>Mean ratio of triangle = area/(a*a + b*b + c*c)<li>Area<li>Texture Angle Distortion. Difference between angle in 3D space and texture space<li>Texture Area Distortion. Difference between area in 3D space and texture space<li>Polygonal Planarity (max distance to support plane)<li>Polygonal Planarity (relative distance to support plane)
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Metric: </TD> <TD><i> Choose a metric to compute triangle quality. -- </i></TD> </TR>
</TABLE>

\section f49 Smooth: Laplacian Vertex Color 

Laplacian Smooth Vertex Color
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Iteration </TD> <TD><i> the number of iteration of the smoothing algorithm -- </i></TD> </TR>
</TABLE>

\section f50 Smooth: Laplacian Face Color 

Laplacian Smooth Face Color
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Iteration </TD> <TD><i> the number of iteration of the smoothing algorithm -- </i></TD> </TR>
</TABLE>

\section f51 Transfer Color: Face to Vertex 

Face to Vertex color transfer
<H2> Parameters </h2>
No parameters.<br>
\section f52 Transfer Color: Texture to Vertex 

Texture to Vertex color transfer
<H2> Parameters </h2>
No parameters.<br>
\section f53 Transfer Color: Vertex to Face 

Vertex to Face color transfer
<H2> Parameters </h2>
No parameters.<br>
\section f54 Transfer Color: Mesh to Face 

Mesh to Face color transfer
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Apply to all Meshes </TD> <TD><i> If true the color mapping is applied to all the meshes. -- </i></TD> </TR>
</TABLE>

\section f55 Random Face Color 

Colorize Faces randomly. If internal edges are present they are used. Useful for quads.
<H2> Parameters </h2>
No parameters.<br>
\section f56 Random Component Color 

Colorize each connected component randomly.
<H2> Parameters </h2>
No parameters.<br>
\section f57 Box/Cube 

Create a Box, Cube, Hexahedron. You can specify the side length.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Scale factor </TD> <TD><i> Scales the new mesh -- </i></TD> </TR>
</TABLE>

\section f58 Annulus 

Create an Annulus e.g. a flat region bounded by two concentric circles, or a holed disk.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Internal Radius </TD> <TD><i> Internal Radius of the annulus -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> External Radius </TD> <TD><i> Externale Radius of the annulus -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Sides </TD> <TD><i> Number of the sides of the poligonal approximation of the annulus  -- </i></TD> </TR>
</TABLE>

\section f59 Sphere 

Create a Sphere, whose topology is obtained as regular subdivision of an icosahedron.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Radius </TD> <TD><i> Radius of the sphere -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Subdiv. Level </TD> <TD><i> Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces).<br>Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere) -- </i></TD> </TR>
</TABLE>

\section f60 Sphere Cap 

Create a Sphere Cap, or spherical dome, subtended by a cone of given angle
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Angle </TD> <TD><i> Angle of the cone subtending the cap. It must be < 180 -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Subdiv. Level </TD> <TD><i> Number of the recursive subdivision of the surface. Default is 3 (a sphere approximation composed by 1280 faces).<br>Admitted values are in the range 0 (an icosahedron) to 8 (a 1.3 MegaTris approximation of a sphere) -- </i></TD> </TR>
</TABLE>

\section f61 Points on a Sphere 

Create a spherical point cloud, it can be random or regularly distributed.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Point Num </TD> <TD><i> Number of points (approximate). -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Generation Technique: </TD> <TD><i> Generation Technique:<b>Montecarlo</b>: The points are randomly generated with an uniform distribution.<br><b>Poisson Disk</b>: The points are to follow a poisson disk distribution.<br><b>Disco Ball</b> Dave Rusin's disco ball algorithm for the regular placement of points on a sphere is used. <br><b>Recursive Octahedron</b> Points are generated on the vertex of a recursively subdivided octahedron <br><b>Fibonacci</b> .  -- </i></TD> </TR>
</TABLE>

\section f62 Icosahedron 

Create an Icosahedron
<H2> Parameters </h2>
No parameters.<br>
\section f63 Dodecahedron 

Create an Dodecahedron
<H2> Parameters </h2>
No parameters.<br>
\section f64 Tetrahedron 

Create a Tetrahedron
<H2> Parameters </h2>
No parameters.<br>
\section f65 Octahedron 

Create an Octahedron
<H2> Parameters </h2>
No parameters.<br>
\section f66 Cone 

Create a Cone
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Radius 1 </TD> <TD><i> Radius of the bottom circumference -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Radius 2 </TD> <TD><i> Radius of the top circumference -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Height </TD> <TD><i> Height of the Cone -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Side </TD> <TD><i> Number of sides of the polygonal approximation of the cone -- </i></TD> </TR>
</TABLE>

\section f67 Torus 

Create a Torus
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Horizontal Radius </TD> <TD><i> Radius of the whole horizontal ring of the torus -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Vertical Radius </TD> <TD><i> Radius of the vertical section of the ring -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Horizontal Subdivision </TD> <TD><i> Subdivision step of the ring -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Vertical Subdivision </TD> <TD><i> Number of sides of the polygonal approximation of the torus section -- </i></TD> </TR>
</TABLE>

\section f68 Fit a plane to selection 

Create a quad on the plane fitting the selection
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Extent (with respect to selection) </TD> <TD><i> How large is the plane, with respect to the size of the selection: 1.0 means as large as the selection, 1.1 means 10% larger thena the selection -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Plane XY subivisions </TD> <TD><i> Subdivision steps of plane borders -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> UV parametrized </TD> <TD><i> The created plane has an UV parametrization -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Plane orientation </TD> <TD><i> Orientation:<b>quasi-Straight Fit</b>: The fitting plane will be oriented (as much as possible) straight with the axeses.<br><b>Best Fit</b>: The fitting plane will be oriented and sized trying to best fit to the selected area.<br><b>-- Parallel</b>: The fitting plane will be oriented with a side parallel with the chosen plane. WARNING: do not use if the selection is exactly parallel to a plane.<br> -- </i></TD> </TR>
</TABLE>

\section f69 Noisy Isosurface 

Create a isosurface perturbed by a noisy isosurface.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Grid Resolution </TD> <TD><i> Resolution of the side of the cubic grid used for the volume creation -- </i></TD> </TR>
</TABLE>

\section f70 CSG Operation 

Constructive Solid Geometry operation filter.<br>For more details see: <br><i>C. Rocchini, P. Cignoni, F. Ganovelli, C. Montani, P. Pingi and R.Scopigno, </i><br><b>'Marching Intersections: an Efficient Resampling Algorithm for Surface Management'</b><br>In Proceedings of Shape Modeling International (SMI) 2001
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> First Mesh </TD> <TD><i> The first operand of the CSG operation -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Second Mesh </TD> <TD><i> The second operand of the CSG operation -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Spacing between sampling lines </TD> <TD><i> This parameter controls the accuracy of the result and the speed of the computation.The time and memory needed to perform the operation usually scale as the reciprocal square of this value.For optimal results, this value should be at most half the the smallest feature (i.e. the highest frequency) you want to reproduce. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Discretization points per sample interval </TD> <TD><i> This is the number of points between the sampling lines to which the vertices can be rounded.Increasing this can marginally increase the precision and decrease the speed of the operation. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Operator </TD> <TD><i> Intersection takes the volume shared between the two meshes; Union takes the volume included in at least one of the two meshes; Difference takes the volume included in the first mesh but not in the second one -- </i></TD> </TR>
</TABLE>

\section f71 Dust Accumulation 

Simulate dust accumulation over the mesh generating a cloud of points lying on the current mesh
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Point3f  </TD> <TD> Direction </TD> <TD><i> Direction of the dust source -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> max particles x face </TD> <TD><i> Max Number of Dust Particles to Generate Per Face -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> s </TD> <TD><i> The surface slippines(large s means less sticky) -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> k </TD> <TD><i> Factor to model the general adhesion -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Draw Dust </TD> <TD><i> create a new texture saved in dirt_texture.png -- </i></TD> </TR>
</TABLE>

\section f72 Points Cloud Movement 

Simulate the movement of a points cloud over a mesh
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Point3f  </TD> <TD> g </TD> <TD><i> Direction of gravity -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> force </TD> <TD><i> Direction of the force acting on the points cloud -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> s </TD> <TD><i> Simulation Steps -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> adhesion </TD> <TD><i> Factor to model the general adhesion. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> v </TD> <TD><i> Initial velocity of the particle -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> m </TD> <TD><i> Mass of the particle -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Map to Color </TD> <TD><i> Color the mesh with colors based on the movement of the particle -- </i></TD> </TR>
</TABLE>

\section f73 Fractal Terrain 

Generates a fractal terrain perturbation with five different algorithms.<br />
Some good parameter values to start with are:<br />
<table align="center">
    <tr style="border:1px solid black">
        <td> - </td>
        <td align="center"> Seed </td>
        <td align="center"> Octaves </td>
        <td align="center"> Lacunarity </td>
        <td align="center"> Fractal increment </td>
        <td align="center"> Offset </td>
        <td align="center"> Gain </td>
    </tr>
    <tr>
        <td>fBM</td>
        <td align="center">1</td>
        <td align="center">10</td>
        <td align="center">2</td>
        <td align="center">1.2</td>
        <td align="center">-</td>
        <td align="center">-</td>
    </tr>
    <tr>
        <td>Standard multifractal</td>
        <td align="center">1</td>
        <td align="center">8</td>
        <td align="center">2</td>
        <td align="center">0.9</td>
        <td align="center">0.9</td>
        <td align="center">-</td>
    </tr>
    <tr>
        <td>Heterogeneous multifractal</td>
        <td align="center">1</td>
        <td align="center">8</td>
        <td align="center">3</td>
        <td align="center">0.9</td>
        <td align="center">0.4</td>
        <td align="center">-</td>
    </tr>
    <tr>
        <td>Hybrid multifractal</td>
        <td align="center">1</td>
        <td align="center">8</td>
        <td align="center">4</td>
        <td align="center">0.1</td>
        <td align="center">0.3</td>
        <td align="center">-</td>
    </tr>
    <tr>
        <td>Ridged multifractal</td>
        <td align="center">2</td>
        <td align="center">8</td>
        <td align="center">4</td>
        <td align="center">0.5</td>
        <td align="center">0.9</td>
        <td align="center">2</td>
    </tr>
</table>
<br /><br />
Detailed algorithms descriptions can be found in:<br />
<i>Ebert, D.S., Musgrave, F.K., Peachey, D., Perlin, K., and Worley, S.</i><br />
<b>Texturing and Modeling: A Procedural Approach</b><br />
Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2002.<br>



<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Subdivision steps: </TD> <TD><i> Defines the detail of the generated terrain. Allowed values are in range [2,9]. Use values from 6 to 9 to obtain reasonable results. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Max height: </TD> <TD><i> Defines the maximum perturbation height as a fraction of the terrain's side. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Scale factor: </TD> <TD><i> Scales the fractal perturbation in and out. Values larger than 1 mean zoom out; values smaller than one mean zoom in. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Seed: </TD> <TD><i> By varying this seed, the terrain morphology will change.
Don't change the seed if you want to refine the current terrain morphology by changing the other parameters. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Algorithm </TD> <TD><i> The algorithm with which the fractal terrain will be generated. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Octaves: </TD> <TD><i> The number of Perlin noise frequencies that will be used to generate the terrain. Reasonable values are in range [2,9]. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Lacunarity: </TD> <TD><i> The gap between noise frequencies. This parameter is used in conjunction with fractal increment to compute the spectral weights that contribute to the noise in each octave. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Fractal increment: </TD> <TD><i> This parameter defines how rough the generated terrain will be. The range of reasonable values changes according to the used algorithm, however you can choose it in range [0.2, 1.5]. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Offset: </TD> <TD><i> This parameter controls the multifractality of the generated terrain. If offset is low, then the terrain will be smooth. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Gain: </TD> <TD><i> Ignored in all the algorithms except the ridged one. This parameter defines how hard the terrain will be. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Save as vertex quality </TD> <TD><i> Saves the perturbation value as vertex quality. -- </i></TD> </TR>
</TABLE>

\section f74 Fractal Displacement 

Generates a fractal terrain perturbation with five different algorithms.<br />
Some good parameter values to start with are:<br />
<table align="center">
    <tr style="border:1px solid black">
        <td> - </td>
        <td align="center"> Seed </td>
        <td align="center"> Octaves </td>
        <td align="center"> Lacunarity </td>
        <td align="center"> Fractal increment </td>
        <td align="center"> Offset </td>
        <td align="center"> Gain </td>
    </tr>
    <tr>
        <td>fBM</td>
        <td align="center">1</td>
        <td align="center">10</td>
        <td align="center">2</td>
        <td align="center">1.2</td>
        <td align="center">-</td>
        <td align="center">-</td>
    </tr>
    <tr>
        <td>Standard multifractal</td>
        <td align="center">1</td>
        <td align="center">8</td>
        <td align="center">2</td>
        <td align="center">0.9</td>
        <td align="center">0.9</td>
        <td align="center">-</td>
    </tr>
    <tr>
        <td>Heterogeneous multifractal</td>
        <td align="center">1</td>
        <td align="center">8</td>
        <td align="center">3</td>
        <td align="center">0.9</td>
        <td align="center">0.4</td>
        <td align="center">-</td>
    </tr>
    <tr>
        <td>Hybrid multifractal</td>
        <td align="center">1</td>
        <td align="center">8</td>
        <td align="center">4</td>
        <td align="center">0.1</td>
        <td align="center">0.3</td>
        <td align="center">-</td>
    </tr>
    <tr>
        <td>Ridged multifractal</td>
        <td align="center">2</td>
        <td align="center">8</td>
        <td align="center">4</td>
        <td align="center">0.5</td>
        <td align="center">0.9</td>
        <td align="center">2</td>
    </tr>
</table>
<br /><br />
Detailed algorithms descriptions can be found in:<br />
<i>Ebert, D.S., Musgrave, F.K., Peachey, D., Perlin, K., and Worley, S.</i><br />
<b>Texturing and Modeling: A Procedural Approach</b><br />
Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2002.<br>


<br /><br />Hint: search a good compromise between offset and height factor parameter.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Max height: </TD> <TD><i> Defines the maximum height for the perturbation. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Scale factor: </TD> <TD><i> Scales the fractal perturbation in and out. Values larger than 1 mean zoom out; values smaller than one mean zoom in. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Normals smoothing steps: </TD> <TD><i> Face normals will be smoothed to make the perturbation more homogeneous. This parameter represents the number of smoothing steps. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Seed: </TD> <TD><i> By varying this seed, the terrain morphology will change.
Don't change the seed if you want to refine the current terrain morphology by changing the other parameters. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Algorithm </TD> <TD><i> The algorithm with which the fractal terrain will be generated. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Octaves: </TD> <TD><i> The number of Perlin noise frequencies that will be used to generate the terrain. Reasonable values are in range [2,9]. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Lacunarity: </TD> <TD><i> The gap between noise frequencies. This parameter is used in conjunction with fractal increment to compute the spectral weights that contribute to the noise in each octave. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Fractal increment: </TD> <TD><i> This parameter defines how rough the generated terrain will be. The range of reasonable values changes according to the used algorithm, however you can choose it in range [0.2, 1.5]. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Offset: </TD> <TD><i> This parameter controls the multifractality of the generated terrain. If offset is low, then the terrain will be smooth. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Gain: </TD> <TD><i> Ignored in all the algorithms except the ridged one. This parameter defines how hard the terrain will be. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Save as vertex quality </TD> <TD><i> Saves the perturbation value as vertex quality. -- </i></TD> </TR>
</TABLE>

\section f75 Craters Generation 

Generates craters onto a mesh using radial functions.<br />
There must be at least two layers to apply this filter:<br />
<ul>
    <li>the layer that contains the target mesh; we assume that this mesh is sufficiently refined;</li>
    <li>the layer that contains the samples which represent the central points of craters.</li>
</ul>

There are three radial functions available to generate craters, two of which are Gaussian and Multiquadric,
and the third is a variant of multiquadric. Blending functions are also provided to blend
the crater elevation towards the mesh surface.
If you want the preview to work, be sure to select the target mesh layer before launching the
filter. You can select this layer by clicking on it in the layer dialog.

<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Target mesh: </TD> <TD><i> The mesh on which craters will be generated. -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Samples layer: </TD> <TD><i> The samples that represent the central points of craters. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Seed: </TD> <TD><i> The seed with which the random number generator is initialized. The random generator generates radius and depth for each crater into the given range. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Normals smoothing steps: </TD> <TD><i> Vertex normals are smoothed this number of times before generating craters. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Radial function: </TD> <TD><i> The radial function used to generate craters. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Min crater radius: </TD> <TD><i> Defines the minimum radius of craters in range [0, 1]. Values near 0 mean very small craters. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Max crater radius: </TD> <TD><i> Defines the maximum radius of craters in range [0, 1]. Values near 1 mean very large craters. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Min crater depth: </TD> <TD><i> Defines the minimum depth of craters in range [0, 1]. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Max crater depth: </TD> <TD><i> Defines the maximum depth of craters in range [0, 1]. Values near 1 mean very deep craters. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Elevation: </TD> <TD><i> Defines how much the crater rise itself from the mesh surface, giving an "impact-effect". -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Blending algorithm: </TD> <TD><i> The algorithm that is used to blend the perturbation towards the mesh surface. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Blending threshold: </TD> <TD><i> The fraction of craters radius beyond which the radial function is replaced with the blending function. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Successive impacts </TD> <TD><i> If not checked, the impact-effects of generated craters will be superimposed with each other. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Postprocessing noise </TD> <TD><i> Slightly perturbates the craters with a noise function. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Invert perturbation </TD> <TD><i> If checked, inverts the sign of radial perturbation to create bumps instead of craters. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Save as vertex quality </TD> <TD><i> Saves the perturbation as vertex quality. -- </i></TD> </TR>
</TABLE>

\section f76 Conditional Vertex Selection 

Boolean function using muparser lib to perform vertex selection over current mesh.<br><br>It's possible to use parenthesis <b>()</b>, and predefined operators:<br><b>&&</b> (logic and), <b>||</b> (logic or), <b>&lt;</b>, <b>&lt;=</b>, <b>></b>, <b>>=</b>, <b>!=</b> (not equal), <b>==</b> (equal), <b>_?_:_</b> (c/c++ ternary operator)<br><br>It's possible to use the following per-vertex variables in the expression:<br><b>x,y,z</b> (position), <b>nx,ny,nz</b> (normal), <b>r,g,b,a</b> (color), <b>q</b> (quality), <b>rad</b> (radius), <b>vi</b> (vertex index), <b>vtu,vtv,ti</b> (texture coords and texture index), <b>vsel</b> (is the vertex selected? 1 yes, 0 no) and all custom <i>vertex attributes</i> already defined by user.<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> boolean function </TD> <TD><i> type a boolean function that will be evaluated in order to select a subset of vertices<br>example: (y > 0) and (ny > 0) -- </i></TD> </TR>
</TABLE>

\section f77 Conditional Face Selection 

Boolean function using muparser lib to perform faces selection over current mesh.<br><br>It's possible to use parenthesis <b>()</b>, and predefined operators:<br><b>&&</b> (logic and), <b>||</b> (logic or), <b>&lt;</b>, <b>&lt;=</b>, <b>></b>, <b>>=</b>, <b>!=</b> (not equal), <b>==</b> (equal), <b>_?_:_</b> (c/c++ ternary operator)<br><br>It's possible to use the following per-face variables, or variables associated to the three vertex of every face:<br><b>x0,y0,z0</b> for the first vertex position, <b>x1,y1,z1</b> for the second vertex position, <b>x2,y2,z2</b> for the third vertex position, <b>nx0,ny0,nz0 nx1,ny1,nz1 nx2,ny2,nz2</b> for vertex normals, <b>r0,g0,b0,a0 r1,g1,b1,a1 r2,g2,b2,a2</b> for vertex colors, <b>q0,q1,q2</b> for vertex quality, <b>wtu0,wtv0 wtu1,wtv1 wtu2,wtv2</b> for per-wedge texture coords, <b>ti</b> for face texture index, <b>vsel0,vsel1,vsel2</b> for vertex selection (1 yes, 0 no) <b>fr,fg,fb,fa</b> for face color, <b>fq</b> for face quality, <b>fnx,fny,fnz</b> for face normal, <b>fsel</b> face selection (1 yes, 0 no).<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> boolean function </TD> <TD><i> type a boolean function that will be evaluated in order to select a subset of faces<br> -- </i></TD> </TR>
</TABLE>

\section f78 Per Vertex Geometric Function 

Geometric function using muparser lib to generate new Coord<br>You can change x,y,z for every vertex according to the function specified.<br>It's possible to use the following per-vertex variables in the expression:<br><b>x,y,z</b> (position), <b>nx,ny,nz</b> (normal), <b>r,g,b,a</b> (color), <b>q</b> (quality), <b>rad</b> (radius), <b>vi</b> (vertex index), <b>vtu,vtv,ti</b> (texture coords and texture index), <b>vsel</b> (is the vertex selected? 1 yes, 0 no) and all custom <i>vertex attributes</i> already defined by user.<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> func x =  </TD> <TD><i> insert function to generate new coord for x -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func y =  </TD> <TD><i> insert function to generate new coord for y -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func z =  </TD> <TD><i> insert function to generate new coord for z -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> only on selection </TD> <TD><i> if checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f79 Per Wedge Texture Function 

Texture function using muparser to generate new per wedge tex coords for every face<br>Insert six functions each u v for each one of the three vertex of a face<br>It's possible to use the following per-face variables, or variables associated to the three vertex of every face:<br><b>x0,y0,z0</b> for the first vertex position, <b>x1,y1,z1</b> for the second vertex position, <b>x2,y2,z2</b> for the third vertex position, <b>nx0,ny0,nz0 nx1,ny1,nz1 nx2,ny2,nz2</b> for vertex normals, <b>r0,g0,b0,a0 r1,g1,b1,a1 r2,g2,b2,a2</b> for vertex colors, <b>q0,q1,q2</b> for vertex quality, <b>wtu0,wtv0 wtu1,wtv1 wtu2,wtv2</b> for per-wedge texture coords, <b>ti</b> for face texture index, <b>vsel0,vsel1,vsel2</b> for vertex selection (1 yes, 0 no) <b>fr,fg,fb,fa</b> for face color, <b>fq</b> for face quality, <b>fnx,fny,fnz</b> for face normal, <b>fsel</b> face selection (1 yes, 0 no).<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> func u0 =  </TD> <TD><i> function to generate u texture coord. of wedge 0. Expected Range 0-1 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func v0 =  </TD> <TD><i> function to generate v texture coord. of wedge 0. Expected Range 0-1 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func u1 =  </TD> <TD><i> function to generate u texture coord. of wedge 1. Expected Range 0-1 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func v1 =  </TD> <TD><i> function to generate v texture coord. of wedge 1. Expected Range 0-1 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func u2 =  </TD> <TD><i> function to generate u texture coord. of wedge 2. Expected Range 0-1 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func v2 =  </TD> <TD><i> function to generate v texture coord. of wedge 2. Expected Range 0-1 -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> only on selection </TD> <TD><i> if checked, only affects selected faces -- </i></TD> </TR>
</TABLE>

\section f80 Per Vertex Texture Function 

Texture function using muparser to generate new texture coords for every vertex<br>It's possible to use the following per-vertex variables in the expression:<br><b>x,y,z</b> (position), <b>nx,ny,nz</b> (normal), <b>r,g,b,a</b> (color), <b>q</b> (quality), <b>rad</b> (radius), <b>vi</b> (vertex index), <b>vtu,vtv,ti</b> (texture coords and texture index), <b>vsel</b> (is the vertex selected? 1 yes, 0 no) and all custom <i>vertex attributes</i> already defined by user.<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> func u =  </TD> <TD><i> function to generate u texture coord. Expected Range 0-1 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func v =  </TD> <TD><i> function to generate v texture coord. Expected Range 0-1 -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> only on selection </TD> <TD><i> if checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f81 Per Face Color Function 

Color function using muparser lib to generate new RGBA color for every face<br>Red, Green, Blue and Alpha channels may be defined specifying a function in their respective fields.<br>It's possible to use the following per-face variables, or variables associated to the three vertex of every face:<br><b>x0,y0,z0</b> for the first vertex position, <b>x1,y1,z1</b> for the second vertex position, <b>x2,y2,z2</b> for the third vertex position, <b>nx0,ny0,nz0 nx1,ny1,nz1 nx2,ny2,nz2</b> for vertex normals, <b>r0,g0,b0,a0 r1,g1,b1,a1 r2,g2,b2,a2</b> for vertex colors, <b>q0,q1,q2</b> for vertex quality, <b>wtu0,wtv0 wtu1,wtv1 wtu2,wtv2</b> for per-wedge texture coords, <b>ti</b> for face texture index, <b>vsel0,vsel1,vsel2</b> for vertex selection (1 yes, 0 no) <b>fr,fg,fb,fa</b> for face color, <b>fq</b> for face quality, <b>fnx,fny,fnz</b> for face normal, <b>fsel</b> face selection (1 yes, 0 no).<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> func r =  </TD> <TD><i> function to generate Red component. Expected Range 0-255 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func g =  </TD> <TD><i> function to generate Green component. Expected Range 0-255 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func b =  </TD> <TD><i> function to generate Blue component. Expected Range 0-255 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func alpha =  </TD> <TD><i> function to generate Alpha component. Expected Range 0-255 -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> only on selection </TD> <TD><i> if checked, only affects selected faces -- </i></TD> </TR>
</TABLE>

\section f82 Per Vertex Color Function 

Color function using muparser lib to generate new RGBA color for every vertex<br>Red, Green, Blue and Alpha channels may be defined specifying a function in their respective fields.<br>It's possible to use the following per-vertex variables in the expression:<br><b>x,y,z</b> (position), <b>nx,ny,nz</b> (normal), <b>r,g,b,a</b> (color), <b>q</b> (quality), <b>rad</b> (radius), <b>vi</b> (vertex index), <b>vtu,vtv,ti</b> (texture coords and texture index), <b>vsel</b> (is the vertex selected? 1 yes, 0 no) and all custom <i>vertex attributes</i> already defined by user.<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> func r =  </TD> <TD><i> function to generate Red component. Expected Range 0-255 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func g =  </TD> <TD><i> function to generate Green component. Expected Range 0-255 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func b =  </TD> <TD><i> function to generate Blue component. Expected Range 0-255 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func alpha =  </TD> <TD><i> function to generate Alpha component. Expected Range 0-255 -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> only on selection </TD> <TD><i> if checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f83 Per Vertex Quality Function 

Quality function using muparser to generate new Quality for every vertex<br>It's possible to use the following per-vertex variables in the expression:<br><b>x,y,z</b> (position), <b>nx,ny,nz</b> (normal), <b>r,g,b,a</b> (color), <b>q</b> (quality), <b>rad</b> (radius), <b>vi</b> (vertex index), <b>vtu,vtv,ti</b> (texture coords and texture index), <b>vsel</b> (is the vertex selected? 1 yes, 0 no) and all custom <i>vertex attributes</i> already defined by user.<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> func q =  </TD> <TD><i> function to generate new Quality for every vertex -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> normalize </TD> <TD><i> if checked normalize all quality values in range [0..1] -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> map into color </TD> <TD><i> if checked map quality generated values into per-vertex color -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> only on selection </TD> <TD><i> if checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f84 Per Vertex Normal Function 

Normal function using muparser to generate new Normal for every vertex<br>It's possible to use the following per-vertex variables in the expression:<br><b>x,y,z</b> (position), <b>nx,ny,nz</b> (normal), <b>r,g,b,a</b> (color), <b>q</b> (quality), <b>rad</b> (radius), <b>vi</b> (vertex index), <b>vtu,vtv,ti</b> (texture coords and texture index), <b>vsel</b> (is the vertex selected? 1 yes, 0 no) and all custom <i>vertex attributes</i> already defined by user.<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> func nx =  </TD> <TD><i> insert function to generate new x for the normal -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func ny =  </TD> <TD><i> insert function to generate new y for the normal -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> func nz =  </TD> <TD><i> insert function to generate new z for the normal -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> only on selection </TD> <TD><i> if checked, only affects selected vertices -- </i></TD> </TR>
</TABLE>

\section f85 Per Face Quality Function 

Quality function using muparser to generate new Quality for every face<br>Insert three function each one for quality of the three vertex of a face<br>It's possible to use the following per-face variables, or variables associated to the three vertex of every face:<br><b>x0,y0,z0</b> for the first vertex position, <b>x1,y1,z1</b> for the second vertex position, <b>x2,y2,z2</b> for the third vertex position, <b>nx0,ny0,nz0 nx1,ny1,nz1 nx2,ny2,nz2</b> for vertex normals, <b>r0,g0,b0,a0 r1,g1,b1,a1 r2,g2,b2,a2</b> for vertex colors, <b>q0,q1,q2</b> for vertex quality, <b>wtu0,wtv0 wtu1,wtv1 wtu2,wtv2</b> for per-wedge texture coords, <b>ti</b> for face texture index, <b>vsel0,vsel1,vsel2</b> for vertex selection (1 yes, 0 no) <b>fr,fg,fb,fa</b> for face color, <b>fq</b> for face quality, <b>fnx,fny,fnz</b> for face normal, <b>fsel</b> face selection (1 yes, 0 no).<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> func q0 =  </TD> <TD><i> function to generate new Quality foreach face -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> normalize </TD> <TD><i> if checked normalize all quality values in range [0..1] -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> map into color </TD> <TD><i> if checked map quality generated values into per-vertex color -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> only on selection </TD> <TD><i> if checked, only affects selected faces -- </i></TD> </TR>
</TABLE>

\section f86 Define New Per Vertex Attribute 

Add a new Per-Vertex scalar attribute to current mesh and fill it with the defined function.<br>The name specified below can be used in other filter functionIt's possible to use the following per-vertex variables in the expression:<br><b>x,y,z</b> (position), <b>nx,ny,nz</b> (normal), <b>r,g,b,a</b> (color), <b>q</b> (quality), <b>rad</b> (radius), <b>vi</b> (vertex index), <b>vtu,vtv,ti</b> (texture coords and texture index), <b>vsel</b> (is the vertex selected? 1 yes, 0 no) and all custom <i>vertex attributes</i> already defined by user.<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> Name </TD> <TD><i> the name of new attribute. you can access attribute in other filters through this name -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Function = </TD> <TD><i> function to calculate custom attribute value for each vertex -- </i></TD> </TR>
</TABLE>

\section f87 Define New Per Face Attribute 

Add a new Per-Face attribute to current mesh.<br>You can specify custom name and a function to generate attribute's value<br>It's possible to use per-face variables in the expression:<br>It's possible to use the following per-face variables, or variables associated to the three vertex of every face:<br><b>x0,y0,z0</b> for the first vertex position, <b>x1,y1,z1</b> for the second vertex position, <b>x2,y2,z2</b> for the third vertex position, <b>nx0,ny0,nz0 nx1,ny1,nz1 nx2,ny2,nz2</b> for vertex normals, <b>r0,g0,b0,a0 r1,g1,b1,a1 r2,g2,b2,a2</b> for vertex colors, <b>q0,q1,q2</b> for vertex quality, <b>wtu0,wtv0 wtu1,wtv1 wtu2,wtv2</b> for per-wedge texture coords, <b>ti</b> for face texture index, <b>vsel0,vsel1,vsel2</b> for vertex selection (1 yes, 0 no) <b>fr,fg,fb,fa</b> for face color, <b>fq</b> for face quality, <b>fnx,fny,fnz</b> for face normal, <b>fsel</b> face selection (1 yes, 0 no).<br><font color="#FF0000">The attribute name specified below can be used in other filter function</font>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> Name </TD> <TD><i> the name of new attribute. you can access attribute in other filters through this name -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Function = </TD> <TD><i> function to calculate custom attribute value for each face -- </i></TD> </TR>
</TABLE>

\section f88 Grid Generator 

Generate a new 2D Grid mesh with number of vertices on X and Y axis specified by user with absolute length/height.<br>It's possible to center Grid on origin.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> num vertices on x </TD> <TD><i> number of vertices on x. it must be positive -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> num vertices on y </TD> <TD><i> number of vertices on y. it must be positive -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> x scale </TD> <TD><i> absolute scale on x (float) -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> y scale </TD> <TD><i> absolute scale on y (float) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> centered on origin </TD> <TD><i> center grid generated by filter on origin.<br>Grid is first generated and than moved into origin (using muparser lib to perform fast calc on every vertex) -- </i></TD> </TR>
</TABLE>

\section f89 Implicit Surface 

Generate a new mesh that corresponds to the 0 valued isosurface defined by the scalar field generated by the given expression
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Size of Voxel </TD> <TD><i> Size of the voxel that is used by for the grid where the field is sampled. Smaller this value, higher precision, but higher processing times. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Min X </TD> <TD><i> Range where the field is sampled -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Min Y </TD> <TD><i> Range where the field is sampled -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Min Z </TD> <TD><i> Range where the field is sampled -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Max X </TD> <TD><i> Range where the field is sampled -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Max Y </TD> <TD><i> Range where the field is sampled -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Max Z </TD> <TD><i> Range where the field is sampled -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Function = </TD> <TD><i> This expression is evaluated for each voxel of the grid. The surface passing through the zero valued points of this field is then extracted using marching cube. -- </i></TD> </TR>
</TABLE>

\section f90 Refine User-Defined 

Refine current mesh with user defined parameters.<br>Specify a Boolean Function needed to select which edges will be cut for refinement purpose.<br>Each edge is identified with first and second vertex.<br>Arguments accepted are first and second vertex attributes:<br><br>It's possible to use parenthesis <b>()</b>, and predefined operators:<br><b>&&</b> (logic and), <b>||</b> (logic or), <b>&lt;</b>, <b>&lt;=</b>, <b>></b>, <b>>=</b>, <b>!=</b> (not equal), <b>==</b> (equal), <b>_?_:_</b> (c/c++ ternary operator)<br><br>It's possible to use the following per-face variables, or variables associated to the three vertex of every face:<br><b>x0,y0,z0</b> for the first vertex position, <b>x1,y1,z1</b> for the second vertex position, <b>x2,y2,z2</b> for the third vertex position, <b>nx0,ny0,nz0 nx1,ny1,nz1 nx2,ny2,nz2</b> for vertex normals, <b>r0,g0,b0,a0 r1,g1,b1,a1 r2,g2,b2,a2</b> for vertex colors, <b>q0,q1,q2</b> for vertex quality, <b>wtu0,wtv0 wtu1,wtv1 wtu2,wtv2</b> for per-wedge texture coords, <b>ti</b> for face texture index, <b>vsel0,vsel1,vsel2</b> for vertex selection (1 yes, 0 no) <b>fr,fg,fb,fa</b> for face color, <b>fq</b> for face quality, <b>fnx,fny,fnz</b> for face normal, <b>fsel</b> face selection (1 yes, 0 no).<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> boolean function </TD> <TD><i> type a boolean function that will be evaluated on every edge -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> x = </TD> <TD><i> function to generate x coord of new vertex in [x0,x1].<br>For example (x0+x1)/2 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> y = </TD> <TD><i> function to generate x coord of new vertex in [y0,y1].<br>For example (y0+y1)/2 -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> z = </TD> <TD><i> function to generate x coord of new vertex in [z0,z1].<br>For example (z0+z1)/2 -- </i></TD> </TR>
</TABLE>

\section f91 Colorize by border distance 

Store in the quality field the geodesic distance from borders and color the mesh accordingly.
<H2> Parameters </h2>
No parameters.<br>
\section f92 Colorize by geodesic distance from a given point 

Store in the quality field the geodesic distance from a given point on the mesh surface and color the mesh accordingly.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Point3f  </TD> <TD> Starting point </TD> <TD><i> The starting point from which geodesic distance has to be computed. If it is not a surface vertex, the closest vertex to the specified point is used as starting seed point. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Max Distance </TD> <TD><i> If not zero it indicates a cut off value to be used during geodesic distance computation. -- </i></TD> </TR>
</TABLE>

\section f93 Colorize by geodesic distance from the selected points 

Store in the quality field the geodesic distance from the selected points on the mesh surface and color the mesh accordingly.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Max Distance </TD> <TD><i> If not zero it indicates a cut off value to be used during geodesic distance computation. -- </i></TD> </TR>
</TABLE>

\section f94 Global registration 

Compute the rigid transformation aligning two 3d objects.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Reference Mesh </TD> <TD><i> Reference point-cloud or mesh -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Target Mesh </TD> <TD><i> Point-cloud or mesh to be aligned to the reference -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Overlap Ratio </TD> <TD><i> Overlap ratio between the two clouds (command line option: -o) -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Registration tolerance </TD> <TD><i> Tolerance value for the congruent set exploration and LCP computation (command line option: -d) -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Number of samples </TD> <TD><i> Number of samples used in each mesh (command line option: -n) -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Filter: difference of normal (degrees) </TD> <TD><i> Allowed difference of normals allowed between corresponding pairs of points(command line option: -a) -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Filter: difference color </TD> <TD><i> Allowed difference of colors allowed between corresponding pairs of points(command line option: -c) -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Max. Computation time, in seconds </TD> <TD><i> Stop the computation before the end of the exploration (command line option: -t) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use Super4PCS </TD> <TD><i> When disable, use 4PCS algorithm (command line option: -x -- </i></TD> </TR>
</TABLE>

\section f95 Parameterization from registered rasters 

The mesh is parameterized by creating some patches that correspond to projection of portions of surfaces onto the set of registered rasters.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Use distance weight </TD> <TD><i> Includes a weight accounting for the distance to the camera during the computation of reference images -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use image border weight </TD> <TD><i> Includes a weight accounting for the distance to the image border during the computation of reference images -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use image alpha weight </TD> <TD><i> If true, alpha channel of the image is used as additional weight. In this way it is possible to mask-out parts of the images that should not be projected on the mesh. Please note this is not a transparency effect, but just influences the weigthing between different images -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Clean isolated triangles </TD> <TD><i> Remove all patches compound of a single triangle by aggregating them to adjacent patches -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> UV stretching </TD> <TD><i> If true, texture coordinates are stretched so as to cover the full interval [0,1] for both directions -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Texture gutter </TD> <TD><i> Extra boundary to add to each patch before packing in texture space (in pixels) -- </i></TD> </TR>
</TABLE>

\section f96 Parameterization + texturing from registered rasters 

The mesh is parameterized and textured by creating some patches that correspond to projection of portions of surfaces onto the set of registered rasters.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Texture size </TD> <TD><i> Specifies the dimension of the generated texture -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Texture name </TD> <TD><i> Specifies the name of the file into which the texture image will be saved -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Color correction </TD> <TD><i> If true, the final texture is corrected so as to ensure seamless transitions -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Color correction filter </TD> <TD><i> It is the radius (in pixel) of the kernel that is used to compute the difference between corresponding texels in different rasters. Default is 1 that generate a 3x3 kernel. Highest values increase the robustness of the color correction process in the case of strong image-to-geometry misalignments -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use distance weight </TD> <TD><i> Includes a weight accounting for the distance to the camera during the computation of reference images -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use image border weight </TD> <TD><i> Includes a weight accounting for the distance to the image border during the computation of reference images -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use image alpha weight </TD> <TD><i> If true, alpha channel of the image is used as additional weight. In this way it is possible to mask-out parts of the images that should not be projected on the mesh. Please note this is not a transparency effect, but just influences the weigthing between different images -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Clean isolated triangles </TD> <TD><i> Remove all patches compound of a single triangle by aggregating them to adjacent patches -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> UV stretching </TD> <TD><i> If true, texture coordinates are stretched so as to cover the full interval [0,1] for both directions -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Texture gutter </TD> <TD><i> Extra boundary to add to each patch before packing in texture space (in pixels) -- </i></TD> </TR>
</TABLE>

\section f97 Quality from raster coverage (Vertex) 

Compute a quality value representing the number of images into which each vertex of the active mesh is visible.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Normalize </TD> <TD><i> Rescale quality values to the range [0,1] -- </i></TD> </TR>
</TABLE>

\section f98 Quality from raster coverage (Face) 

Compute a quality value representing the number of images into which each face of the active mesh is visible.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Normalize </TD> <TD><i> Rescale quality values to the range [0,1] -- </i></TD> </TR>
</TABLE>

\section f99 Iso Parametrization: Main 

The filter builds the abstract domain mesh representing the Isoparameterization of a watertight two-manifold triangular mesh. <br>This abstract mesh can be used to uniformly remesh the input mesh, or to build a atlased texture parametrization. Abstract Mesh can be also loaded and saved. <br>In short this filter build a very coarse almost regular triangulation such that original mesh can be reprojected from this abstract mesh with minimal distortion.<br>For more details see: <br><b>N. Pietroni, M. Tarini and P. Cignoni</b>, <br><a href="http://vcg.isti.cnr.it/Publications/2010/PTC10/">'Almost isometric mesh parameterization through abstract domains'</a> <br>IEEE Transaction of Visualization and Computer Graphics, 2010
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> AM  Min Size </TD> <TD><i> This number and the following one indicate the range face number of the abstract mesh that is used for the parametrization process.<br>The algorithm will choose the best abstract mesh with the number of triangles within the specified interval.<br>If the mesh has a very simple structure this range can be very low and strict;for a roughly spherical object if you can specify a range of [8,8] faces you get a octahedral abstract mesh, e.g. a geometry image.<br>Large numbers (greater than 400) are usually not of practical use. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> AM Max Size </TD> <TD><i> Please notice that a large interval requires huge amount of memory to be allocated, in order save the intermediate results. <br>An interval of 50 should be fine. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Optimization Criteria </TD> <TD><i> Choose a metric to stop the parametrization within the interval<br>1: Best Heuristic : stop considering both isometry and number of faces of base domain<br>2: Area + Angle : stop at minimum area and angle distorsion<br>3: Regularity : stop at minimum number of irregular vertices<br>4: L2 : stop at minimum OneWay L2 Stretch Eff -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Convergence Precision </TD> <TD><i> This parameter controls the convergence speed/precision of the optimization of the texture coordinates. Larger the number slower the processing and ,eventually, slightly better results -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Double Step </TD> <TD><i> Use this bool to divide the parameterization in 2 steps. Double step makes the overall process faster and robust.<br> Consider to disable this bool in case the object has topologycal noise or small handles. -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Load AM </TD> <TD><i> The filename of the abstract mesh that has to be loaded. If empty, the abstract mesh will be computed according to the above parameters (suggested extension '.abs'). -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Save AM </TD> <TD><i> The filename where the computed abstract mesh will be saved. If empty, nothing will be done. -- </i></TD> </TR>
</TABLE>

\section f100 Iso Parametrization Remeshing 

Uniform Remeshing based on Isoparameterization, each triangle of the domain is recursively subdivided. <br>For more details see: <br><b>N. Pietroni, M. Tarini and P. Cignoni</b>, <br><a href="http://vcg.isti.cnr.it/Publications/2010/PTC10/">'Almost isometric mesh parameterization through abstract domains'</a> <br>IEEE Transaction of Visualization and Computer Graphics, 2010
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Sampling Rate </TD> <TD><i> This specify the sampling rate for remeshing. Must be greater than 2 -- </i></TD> </TR>
</TABLE>

\section f101 Iso Parametrization Build Atlased Mesh 

The filter build a new mesh with a standard atlased per wedge texture. The atlas is simply done by exploiting the low distortion, coarse, regular, mesh of the abstract domain<br>For more details see: <br><b>N. Pietroni, M. Tarini and P. Cignoni</b>, <br><a href="http://vcg.isti.cnr.it/Publications/2010/PTC10/">'Almost isometric mesh parameterization through abstract domains'</a> <br>IEEE Transaction of Visualization and Computer Graphics, 2010
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> BorderSize ratio </TD> <TD><i> This parameter controls the amount of space that must be left between each diamond when building the atlas.It directly affects how many triangle are split during this conversion. <br>In abstract parametrization mesh triangles can naturally cross the triangles of the abstract domain, so when converting to a standard parametrization we must cut all the triangles that protrudes outside each diamond more than the specified threshold.The unit of the threshold is in percentage of the size of the diamond,The bigger the threshold the less triangles are split, but the more UV space is used (wasted). -- </i></TD> </TR>
</TABLE>

\section f102 Iso Parametrization transfer between meshes 

Transfer the Isoparametrization between two meshes, the two meshes must be reasonably similar and well aligned. It is useful to transfer back an isoparam onto the original mesh after having computed it on a dummy, clean watertight model.<br>For more details see: <br><b>N. Pietroni, M. Tarini and P. Cignoni</b>, <br><a href="http://vcg.isti.cnr.it/Publications/2010/PTC10/">'Almost isometric mesh parameterization through abstract domains'</a> <br>IEEE Transaction of Visualization and Computer Graphics, 2010
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Source Mesh </TD> <TD><i> The mesh already having an Isoparameterization -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Target Mesh </TD> <TD><i> The mesh to be Isoparameterized -- </i></TD> </TR>
</TABLE>

\section f103 Flatten Visible Layers 

Flatten all or only the visible layers into a single new mesh. <br> Transformations are preserved. Existing layers can be optionally deleted
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Merge Only Visible Layers </TD> <TD><i> If true, flatten only visible layers, otherwise, all layers are used -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Delete Layers  </TD> <TD><i> Delete all the layers used as source in flattening. <br>If all layers are visible only a single layer will remain after the invocation of this filter -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Merge duplicate vertices </TD> <TD><i> Merge the vertices that are duplicated among different layers. 

Very useful when the layers are spliced portions of a single big mesh. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Keep unreferenced vertices </TD> <TD><i> Do not discard unreferenced vertices from source layers

Necessary for point-cloud layers -- </i></TD> </TR>
</TABLE>

\section f104 Change Visibility of layer(s) 

Make layer(s) visible/invisible. Useful for scripting.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Layer Name </TD> <TD><i> The name of the layer that has to change visibility. If second parameter is not empty, this parameter is ignored -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Substring match </TD> <TD><i> Apply visibility to all layers with name substring matching the entered string. If not empty, the first parameter is ignored. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Visible </TD> <TD><i> It makes the selected layer(s) visible or invisible. -- </i></TD> </TR>
</TABLE>

\section f105 Delete Current Mesh 

The current mesh layer is deleted
<H2> Parameters </h2>
No parameters.<br>
\section f106 Delete all non visible Mesh Layers 

All the non visible mesh layers are deleted
<H2> Parameters </h2>
No parameters.<br>
\section f107 Delete Current Raster 

The current raster layer is deleted
<H2> Parameters </h2>
No parameters.<br>
\section f108 Delete all Non Selected Rasters 

All non selected raster layers are deleted
<H2> Parameters </h2>
No parameters.<br>
\section f109 Move selected faces to another layer 

Selected faces are moved (or duplicated) in a new layer. Warning! per-vertex and per-face user defined attributes will not be transferred.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Delete original selection </TD> <TD><i> Deletes the original selected faces/vertices, thus splitting the mesh among layers. 

if false, the selected faces/vertices are duplicated in the new layer -- </i></TD> </TR>
</TABLE>

\section f110 Move selected vertices to another layer 

Selected vertices are moved (or duplicated) in a new layer. Warning! per-vertex user defined attributes will not be transferred.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Delete original selection </TD> <TD><i> Deletes the original selected faces/vertices, thus splitting the mesh among layers. 

if false, the selected faces/vertices are duplicated in the new layer -- </i></TD> </TR>
</TABLE>

\section f111 Split in Connected Components 

Split current Layer into many layers, one for each connected components
<H2> Parameters </h2>
No parameters.<br>
\section f112 Rename Current Mesh 

Explicitly change the label shown for a given mesh
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> New Label </TD> <TD><i> New Label for the mesh -- </i></TD> </TR>
</TABLE>

\section f113 Rename Current Raster 

Explicitly change the label shown for a given raster
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> New Label </TD> <TD><i> New Label for the raster -- </i></TD> </TR>
</TABLE>

\section f114 Duplicate Current layer 

Create a new layer containing the same model as the current one
<H2> Parameters </h2>
No parameters.<br>
\section f115 Change the current layer 

Change the current layer to a chosen one
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Layer Name </TD> <TD><i> The name of the current layer -- </i></TD> </TR>
</TABLE>

\section f116 Export active rasters cameras to file 

Export active cameras to file, in the .out or Agisoft .xml formats
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Output format </TD> <TD><i> Choose the output format, The filter enables to export the cameras to both Bundler and Agisoft Photoscan. -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Export file name (the right extension will be added at the end) </TD> <TD><i> Name of the output file, it will be saved in the same folder as the project file -- </i></TD> </TR>
</TABLE>

\section f117 Import cameras for active rasters from file 

Import cameras for active rasters from .out or Agisoft .xml formats
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c FileName  </TD> <TD> Choose the camera file to be imported </TD> <TD><i> It's possible to import both Bundler .out and Agisoft .xml files. In both cases, distortion parameters won't be imported. In the case of Agisoft, it's necessary to undistort the images before exporting the xml file -- </i></TD> </TR>
</TABLE>

\section f118 Compute Topological Measures 

Compute a set of topological measures over a mesh.
<H2> Parameters </h2>
No parameters.<br>
\section f119 Compute Topological Measures for Quad Meshes 

Compute a set of topological measures over a quad mesh.
<H2> Parameters </h2>
No parameters.<br>
\section f120 Compute Geometric Measures 

Compute a set of geometric measures of a mesh/pointcloud. Bounding box extents and diagonal, principal axis, thin shell barycenter (mesh only), vertex barycenter and quality-weighted barycenter (pointcloud only), surface area (mesh only), volume (closed mesh) and Inertia tensor Matrix (closed mesh). Open the layer dialog to see the results.
<H2> Parameters </h2>
No parameters.<br>
\section f121 Compute Area/Perimeter of selection 

Compute area and perimeter of the FACE selection. Open the layer dialog to see the results.
<H2> Parameters </h2>
No parameters.<br>
\section f122 Per Vertex Quality Stat 

Compute some aggregate statistics over the per vertex quality, like Min, Max, Average, StdDev and Variance.
<H2> Parameters </h2>
No parameters.<br>
\section f123 Per Face Quality Stat 

Compute some aggregate statistics over the per vertex quality, like Min, Max, Average, StdDev and Variance.
<H2> Parameters </h2>
No parameters.<br>
\section f124 Per Vertex Quality Histogram 

Compute an histogram of the values of the per-vertex quality. It can be useful to evaluate the distribution of the quality value over the surface. It can be discrete (e.g. based on vertex count or area weighted).
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Hist Min </TD> <TD><i> The vertex are displaced of a vector whose norm is bounded by this value -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Hist Max </TD> <TD><i> The vertex are displaced of a vector whose norm is bounded by this value -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Area Weighted </TD> <TD><i> If false, the histogram will report the number of vertices with quality values falling in each bin of the histogram. If true each bin of the histogram will report the approximate area of the mesh with that range of values. Area is computed by assigning to each vertex one third of the area all the incident triangles. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Bin number </TD> <TD><i> The number of bins of the histogram. E.g. the number of intervals in which the min..max range is subdivided into. -- </i></TD> </TR>
</TABLE>

\section f125 Per Face Quality Histogram 

Compute an histogram of the values of the per-face quality.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Hist Min </TD> <TD><i> The faces are displaced of a vector whose norm is bounded by this value -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Hist Max </TD> <TD><i> The faces are displaced of a vector whose norm is bounded by this value -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Area Weighted </TD> <TD><i> If false, the histogram will report the number of faces with quality values falling in each bin of the histogram. If true each bin of the histogram will report the approximate area of the mesh with that range of values. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Bin number </TD> <TD><i> The number of bins of the histogram. E.g. the number of intervals in which the min..max range is subdivided into. -- </i></TD> </TR>
</TABLE>

\section f126 Subdivision Surfaces: Loop 

Apply Loop's Subdivision Surface algorithm. It is an approximant refinement method and it works for every triangle and has rules for extraordinary vertices.<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Weighting scheme </TD> <TD><i> Change the weights used. Allows one to optimize some behaviors over others. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Iterations </TD> <TD><i> Number of time the model is subdivided. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Edge Threshold </TD> <TD><i> All the edges <b>longer</b> than this threshold will be refined.<br>Setting this value to zero will force an uniform refinement. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selected faces </TD> <TD><i> If selected the filter affect only the selected faces -- </i></TD> </TR>
</TABLE>

\section f127 Subdivision Surfaces: Butterfly Subdivision 

Apply Butterfly Subdivision Surface algorithm. It is an interpolated refinement method, defined on arbitrary triangular meshes. The scheme is known to be C1 but not C2 on regular meshes<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Iterations </TD> <TD><i> Number of time the model is subdivided. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Edge Threshold </TD> <TD><i> All the edges <b>longer</b> than this threshold will be refined.<br>Setting this value to zero will force an uniform refinement. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selected faces </TD> <TD><i> If selected the filter affect only the selected faces -- </i></TD> </TR>
</TABLE>

\section f128 Simplification: Clustering Decimation 

Collapse vertices by creating a three dimensional grid enveloping the mesh and discretizes them based on the cells of this grid
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Cell Size </TD> <TD><i> The size of the cell of the clustering grid. Smaller the cell finer the resulting mesh. For obtaining a very coarse mesh use larger values. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selected faces </TD> <TD><i> If selected the filter affect only the selected faces -- </i></TD> </TR>
</TABLE>

\section f129 Simplification: Quadric Edge Collapse Decimation 

Simplify a mesh using a Quadric based Edge Collapse Strategy; better than clustering but slower
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Target number of faces </TD> <TD><i> The desired final number of faces. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Percentage reduction (0..1) </TD> <TD><i> If non zero, this parameter specifies the desired final size of the mesh as a percentage of the initial size. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Quality threshold </TD> <TD><i> Quality threshold for penalizing bad shaped faces.<br>The value is in the range [0..1]
 0 accept any kind of face (no penalties),
 0.5  penalize faces with quality < 0.5, proportionally to their shape
 -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Preserve Boundary of the mesh </TD> <TD><i> The simplification process tries to do not affect mesh boundaries during simplification -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Boundary Preserving Weight </TD> <TD><i> The importance of the boundary during simplification. Default (1.0) means that the boundary has the same importance of the rest. Values greater than 1.0 raise boundary importance and has the effect of removing less vertices on the border. Admitted range of values (0,+inf).  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Preserve Normal </TD> <TD><i> Try to avoid face flipping effects and try to preserve the original orientation of the surface -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Preserve Topology </TD> <TD><i> Avoid all the collapses that should cause a topology change in the mesh (like closing holes, squeezing handles, etc). If checked the genus of the mesh should stay unchanged. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Optimal position of simplified vertices </TD> <TD><i> Each collapsed vertex is placed in the position minimizing the quadric error.
 It can fail (creating bad spikes) in case of very flat areas. 
If disabled edges are collapsed onto one of the two original vertices and the final mesh is composed by a subset of the original vertices.  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Planar Simplification </TD> <TD><i> Add additional simplification constraints that improves the quality of the simplification of the planar portion of the mesh, as a side effect, more triangles will be preserved in flat areas (allowing better shaped triangles). -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Planar Simp. Weight </TD> <TD><i> How much we should try to preserve the triangles in the planar regions. If you lower this value planar areas will be simplified more. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Weighted Simplification </TD> <TD><i> Use the Per-Vertex quality as a weighting factor for the simplification. The weight is used as a error amplification value, so a vertex with a high quality value will not be simplified and a portion of the mesh with low quality values will be aggressively simplified. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Post-simplification cleaning </TD> <TD><i> After the simplification an additional set of steps is performed to clean the mesh (unreferenced vertices, bad faces, etc) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Simplify only selected faces </TD> <TD><i> The simplification is applied only to the selected set of faces.
 Take care of the target number of faces! -- </i></TD> </TR>
</TABLE>

\section f130 Simplification: Quadric Edge Collapse Decimation (with texture) 

Simplify a textured mesh using a Quadric based Edge Collapse Strategy preserving UV parametrization; better than clustering but slower
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Target number of faces </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Percentage reduction (0..1) </TD> <TD><i> If non zero, this parameter specifies the desired final size of the mesh as a percentage of the initial mesh. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Quality threshold </TD> <TD><i> Quality threshold for penalizing bad shaped faces.<br>The value is in the range [0..1]
 0 accept any kind of face (no penalties),
 0.5  penalize faces with quality < 0.5, proportionally to their shape
 -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Texture Weight </TD> <TD><i> Additional weight for each extra Texture Coordinates for every (selected) vertex -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Preserve Boundary of the mesh </TD> <TD><i> The simplification process tries not to destroy mesh boundaries -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Boundary Preserving Weight </TD> <TD><i> The importance of the boundary during simplification. Default (1.0) means that the boundary has the same importance of the rest. Values greater than 1.0 raise boundary importance and has the effect of removing less vertices on the border. Admitted range of values (0,+inf).  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Optimal position of simplified vertices </TD> <TD><i> Each collapsed vertex is placed in the position minimizing the quadric error.
 It can fail (creating bad spikes) in case of very flat areas. 
If disabled edges are collapsed onto one of the two original vertices and the final mesh is composed by a subset of the original vertices.  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Preserve Normal </TD> <TD><i> Try to avoid face flipping effects and try to preserve the original orientation of the surface -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Planar Simplification </TD> <TD><i> Add additional simplification constraints that improves the quality of the simplification of the planar portion of the mesh. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Simplify only selected faces </TD> <TD><i> The simplification is applied only to the selected set of faces.
 Take care of the target number of faces! -- </i></TD> </TR>
</TABLE>

\section f131 Remeshing: Isotropic Explicit Remeshing 

Perform a explicit remeshing of a triangular mesh, by repeatedly applying edge flip, collapse, relax and refine to improve aspect ratio (triangle quality) and topological regularity.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Iterations </TD> <TD><i> Number of iterations of the remeshing operations to repeat on the mesh. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Adaptive remeshing </TD> <TD><i> Toggles adaptive isotropic remeshing. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Remesh only selected faces </TD> <TD><i> If checked the remeshing operations will be applied only to the selected faces. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Target Length </TD> <TD><i> Sets the target length for the remeshed mesh edges. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Crease Angle </TD> <TD><i> Minimum angle between faces of the original to consider the shared edge as a feature to be preserved. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Check Surface Distance </TD> <TD><i> If toggled each local operation must deviate from original mesh by [Max. surface distance] -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Max. Surface Distance </TD> <TD><i> Maximal surface deviation allowed for each local operation -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Refine Step </TD> <TD><i> If checked the remeshing operations will include a refine step. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Collapse Step </TD> <TD><i> If checked the remeshing operations will include a collapse step. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Edge-Swap Step </TD> <TD><i> If checked the remeshing operations will include a edge-swap step, aimed at improving the vertex valence of the resulting mesh. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Smooth Step </TD> <TD><i> If checked the remeshing operations will include a smoothing step, aimed at relaxing the vertex positions in a Laplacian sense. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Reproject Step </TD> <TD><i> If checked the remeshing operations will include a step to reproject the mesh vertices on the original surface. -- </i></TD> </TR>
</TABLE>

\section f132 Subdivision Surfaces: Midpoint 

Apply a plain subdivision scheme where every edge is split on its midpoint. Useful to uniformly refine a mesh substituting each triangle with four smaller triangles.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Iterations </TD> <TD><i> Number of time the model is subdivided. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Edge Threshold </TD> <TD><i> All the edges <b>longer</b> than this threshold will be refined.<br>Setting this value to zero will force an uniform refinement. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selected faces </TD> <TD><i> If selected the filter affect only the selected faces -- </i></TD> </TR>
</TABLE>

\section f133 Re-Orient all faces coherentely 

Re-orient in a consistent way all the faces of the mesh. <br>The filter visits a mesh face to face, reorienting any unvisited face so that it is coherent to the already visited faces. If the surface is orientable it will end with a consistent orientation of all the faces. If the surface is not orientable (e.g. it is non manifold or non orientable like a moebius strip) the filter will not build a consistent orientation simply because it is not possible. The filter can end up in a consistent orientation that can be exactly the opposite of the expected one; in that case simply invert the whole mesh orientation.
<H2> Parameters </h2>
No parameters.<br>
\section f134 Transform: Flip and/or swap axis 

Generate a matrix transformation that flips each one of the axis or swaps a couple of axis. The listed transformations are applied in that order. This kind of transformation cannot be applied to set of Raster!
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Flip X axis </TD> <TD><i> If selected the axis will be swapped (mesh mirrored along the YZ plane -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Flip Y axis </TD> <TD><i> If selected the axis will be swapped (mesh mirrored along the XZ plane -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Flip Z axis </TD> <TD><i> If selected the axis will be swapped (mesh mirrored along the XY plane -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Swap X-Y axis </TD> <TD><i> If selected the two axis will be swapped. All the swaps are performed in this order -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Swap X-Z axis </TD> <TD><i> If selected the two axis will be swapped. All the swaps are performed in this order -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Swap Y-Z axis </TD> <TD><i> If selected the two axis will be swapped. All the swaps are performed in this order -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Freeze Matrix </TD> <TD><i> The transformation is explicitly applied, and the vertex coordinates are actually changed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f135 Transform: Rotate 

Generate a matrix transformation that rotates the mesh. The mesh can be rotated around one of the axis or a given axis and w.r.t. to the origin or the baricenter, or a given point.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Rotation on: </TD> <TD><i> Choose a method -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Center of rotation: </TD> <TD><i> Choose a method -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Rotation Angle </TD> <TD><i> Angle of rotation (in <b>degree</b>). If snapping is enabled this value is rounded according to the snap value -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Custom axis </TD> <TD><i> This rotation axis is used only if the 'custom axis' option is chosen. -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Custom center </TD> <TD><i> This rotation center is used only if the 'custom point' option is chosen. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Snap angle </TD> <TD><i> If selected, before starting the filter will remove any unreferenced vertex (for which curvature values are not defined) -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Snapping Value </TD> <TD><i> This value is used to snap the rotation angle (i.e. if the snapping value is 30, 227 becomes 210). -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Freeze Matrix </TD> <TD><i> The transformation is explicitly applied, and the vertex coordinates are actually changed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f136 Transform: Rotate to Fit to a plane 

Generate a matrix transformation that rotates the mesh so that the selection fits one of the main planes XY YZ ZX. May also translate such that the selection centroid rest on the origin. It reports on the log the average error of the fitting (in mesh units).
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Rotate to fit: </TD> <TD><i> Choose the plane where the selection will fit -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Rotate on: </TD> <TD><i> Choose on which axis do the rotation: 'any axis' guarantee the best fit of the selection to the plane, only use X,Y or Z it if you want to preserve that specific axis. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Move to Origin </TD> <TD><i> Also apply a translation, such that the centroid of selection rests on the Origin -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Freeze Matrix </TD> <TD><i> The transformation is explicitly applied, and the vertex coordinates are actually changed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f137 Transform: Align to Principal Axis 

Generate a matrix transformation that rotates the mesh aligning it to its principal axis of inertia.If the mesh is watertight the Itertia tensor is computed assuming the interior of the mesh has a uniform density.In case of an open mesh or a point clouds the inerta tensor is computed assuming each vertex is a constant puntual mass.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Use vertex </TD> <TD><i> If selected, only the vertices of the mesh are used to compute the Principal Axis. Mandatory for point clouds or for non water tight meshes -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Freeze Matrix </TD> <TD><i> The transformation is explicitly applied, and the vertex coordinates are actually changed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f138 Transform: Scale, Normalize 

Generate a matrix transformation that scale the mesh. The mesh can be also automatically scaled to a unit side box. 
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> X Axis </TD> <TD><i> Scaling -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Y Axis </TD> <TD><i> Scaling -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Z Axis </TD> <TD><i> Scaling -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Uniform Scaling </TD> <TD><i> If selected an uniform scaling (the same for all the three axis) is applied (the X axis value is used) -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Center of scaling: </TD> <TD><i> Choose a method -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Custom center </TD> <TD><i> This scaling center is used only if the 'custom point' option is chosen. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Scale to Unit bbox </TD> <TD><i> If selected, the object is scaled to a box whose sides are at most 1 unit length -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Freeze Matrix </TD> <TD><i> The transformation is explicitly applied, and the vertex coordinates are actually changed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f139 Transform: Translate, Center, set Origin 

Generate a matrix transformation that translate the mesh. The mesh can be translated around one of the axis or a given axis and w.r.t. to the origin or the baricenter, or a given point.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Transformation: </TD> <TD><i> [XYZ translation] adds X,Y and Z offset to Layer transformation, [Center on BBox] moves Layer Origin to the Bounding Box center, [Set new Origin] moves Layer Origin to a specific point -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> X Axis </TD> <TD><i> when using [XYZ translation], amount of translation along the X axis (in model units) -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Y Axis </TD> <TD><i> when using [XYZ translation], amount of translation along the Y axis (in model units) -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Z Axis </TD> <TD><i> when using [XYZ translation], amount of translation along the Z axis (in model units) -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> New Origin: </TD> <TD><i> when using [Set new Origin], this is the location of the new Origin. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Freeze Matrix </TD> <TD><i> The transformation is explicitly applied, and the vertex coordinates are actually changed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f140 Invert Faces Orientation 

Invert faces orientation, flipping the normals of the mesh. <br>If requested, it tries to guess the right orientation; mainly it decide to flip all the faces if the minimum/maximum vertices have not outward point normals for a few directions.<br>Works well for single component watertight objects.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Force Flip </TD> <TD><i> If selected, the normals will always be flipped; otherwise, the filter tries to set them outside -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Flip only selected faces </TD> <TD><i> If selected, only selected faces will be affected -- </i></TD> </TR>
</TABLE>

\section f141 Compute normals for point sets 

Compute the normals of the vertices of a mesh without exploiting the triangle connectivity, useful for dataset with no faces
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Neighbour num </TD> <TD><i> The number of neighbors used to estimate normals. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Smooth Iteration </TD> <TD><i> The number of smoothing iteration done on the p used to estimate and propagate normals. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Flip normals w.r.t. viewpoint </TD> <TD><i> If the 'viewpoint' (i.e. scanner position) is known, it can be used to disambiguate normals orientation, so that all the normals will be oriented in the same direction. -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Viewpoint Pos. </TD> <TD><i> The viewpoint position can be set by hand (i.e. getting the current viewpoint) or it can be retrieved from mesh camera, if the viewpoint position is stored there. -- </i></TD> </TR>
</TABLE>

\section f142 Smooths normals on a point sets 

Smooth the normals of the vertices of a mesh without exploiting the triangle connectivity, useful for dataset with no faces
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Number of neighbors </TD> <TD><i> The number of neighbors used to smooth normals. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Weight using neighbour distance </TD> <TD><i> If selected, the neighbour normals are waighted according to their distance -- </i></TD> </TR>
</TABLE>

\section f143 Compute curvature principal directions 

Compute the principal directions of curvature with several algorithms
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Method: </TD> <TD><i> Choose a method -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Quality/Color Mapping </TD> <TD><i> Choose the curvature that is mapped into quality and visualized as per vertex color. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Remove Unreferenced Vertices </TD> <TD><i> If selected, before starting the filter will remove anyy unreference vertex (for which curvature values are not defined) -- </i></TD> </TR>
</TABLE>

\section f144 Close Holes 

Close holes smaller than a given threshold
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Max size to be closed  </TD> <TD><i> The size is expressed as number of edges composing the hole boundary -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Close holes with selected faces </TD> <TD><i> Only the holes with at least one of the boundary faces selected are closed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Select the newly created faces </TD> <TD><i> After closing a hole the faces that have been created are left selected. Any previous selection is lost. Useful for example for smoothing the newly created holes. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Prevent creation of selfIntersecting faces </TD> <TD><i> When closing an holes it tries to prevent the creation of faces that intersect faces adjacent to the boundary of the hole. It is an heuristic, non intersetcting hole filling can be NP-complete. -- </i></TD> </TR>
</TABLE>

\section f145 Matrix: Freeze Current Matrix 

Freeze the current transformation matrix into the coordinates of the vertices of the mesh (and set this matrix to the identity). In other words it applies in a definetive way the current matrix to the vertex coordinates.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f146 Matrix: Reset Current Matrix 

Set the current transformation matrix to the Identity. 
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f147 Matrix: Invert Current Matrix 

Invert the current transformation matrix. The current transformation is reversed, becoming its opposite.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Freeze Matrix </TD> <TD><i> The transformation is explicitly applied, and the vertex coordinates are actually changed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f148 Matrix: Set from translation/rotation/scale 

Set the current transformation matrix starting from parameters: [XYZ] translation, [XYZ] Euler angles rotation and [XYZ] scaling.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> X Translation </TD> <TD><i> Translation factor on X axis -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Y Translation </TD> <TD><i> Translation factor on Y axis -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Z Translation </TD> <TD><i> Translation factor on Z axis -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> X Rotation </TD> <TD><i> Rotation angle on X axis -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Y Rotation </TD> <TD><i> Rotation angle on Y axis -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Z Rotation </TD> <TD><i> Rotation angle on Z axis -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> X Scale </TD> <TD><i> Scaling factor on X axis -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Y Scale </TD> <TD><i> Scaling factor on Y axis -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Z Scale </TD> <TD><i> Scaling factor on Z axis -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Compose with current </TD> <TD><i> If selected, the new matrix will be composed with the current one (matrix=new*old) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Freeze Matrix </TD> <TD><i> The transformation is explicitly applied, and the vertex coordinates are actually changed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f149 Matrix: Set/Copy Transformation 

Set the current transformation matrix by filling it, or copying from another layer.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Matrix44f  </TD> <TD>  </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Compose with current </TD> <TD><i> If selected, the new matrix will be composed with the current one (matrix=new*old) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Freeze Matrix </TD> <TD><i> The transformation is explicitly applied, and the vertex coordinates are actually changed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected, the filter will be applied to all visible mesh layers -- </i></TD> </TR>
</TABLE>

\section f150 Geometric Cylindrical Unwrapping 

Unwrap the geometry of current mesh along a clylindrical equatorial projection. The cylindrical projection axis is centered on the origin and directed along the vertical <b>Y</b> axis.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Start angle (deg) </TD> <TD><i> The starting angle of the unrolling process. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> End angle (deg) </TD> <TD><i> The ending angle of the unrolling process. Quality threshold for penalizing bad shaped faces.<br>The value is in the range [0..1]
 0 accept any kind of face (no penalties),
 0.5  penalize faces with quality < 0.5, proportionally to their shape
 -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Projection Radius </TD> <TD><i> If non zero, this parameter specifies the desired radius of the reference cylinder used for the projection. Changing this parameter affect the <b>X</b> horizontal scaling of the resulting mesh. If zero (default) the average distance of the mesh from the axis is chosen. -- </i></TD> </TR>
</TABLE>

\section f151 Subdivision Surfaces: Catmull-Clark 

Apply the Catmull-Clark Subdivision Surfaces. Note that position of the new vertices is simply linearly interpolated. If the mesh is triangle based (no <a href='https://stackoverflow.com/questions/59392193'>faux edges</a>) it generates a quad mesh, otherwise it honores it the faux-edge bits
<H2> Parameters </h2>
No parameters.<br>
\section f152 Tri to Quad by 4-8 Subdivision 

Convert a tri mesh into a quad mesh by applying a 4-8 subdivision scheme.It introduces less overhead than the plain Catmull-Clark Subdivision Surfaces(it adds only a single vertex for each triangle instead of four).<br> See: <br><b>4-8 Subdivision</b><br> <i>Luiz Velho, Denis Zorin </i><br>CAGD, volume 18, Issue 5, Pages 397-427. 
<H2> Parameters </h2>
No parameters.<br>
\section f153 Turn into Quad-Dominant mesh 

Convert a tri-mesh into a quad-dominant mesh by pairing suitable triangles.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Optimize For: </TD> <TD><i> Choose any of three different greedy strategies. -- </i></TD> </TR>
</TABLE>

\section f154 Turn into a Pure-Triangular mesh 

Convert into a tri-mesh by splitting any polygonal face.
<H2> Parameters </h2>
No parameters.<br>
\section f155 Tri to Quad by smart triangle pairing 

Convert a tri-mesh into a quad mesh by pairing triangles.
<H2> Parameters </h2>
No parameters.<br>
\section f156 Select Crease Edges 

It select the crease edges of a mesh according to edge dihedral angle.<br>Angle between face normal is considered signed according to convexity/concavity.Convex angles are positive and concave are negative.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Concave Angle Thr. (deg) </TD> <TD><i> Concave Dihedral Angle threshold for considering an edge a crease. If the normals between two faces forms an concave diheadral angle smaller than the threshold the edge is considered a crease. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Convex Angle Thr. (deg) </TD> <TD><i> The angle threshold for considering an edge a crease. If the normals between two faces forms an angle larger than the threshold the edge is considered a crease. -- </i></TD> </TR>
</TABLE>

\section f157 Build a Polyline from Selected Edges 

Create a new Layer with an edge mesh composed only by the selected edges of the current mesh
<H2> Parameters </h2>
No parameters.<br>
\section f158 Vertex Attribute Seam 

Make all selected vertex attributes connectivity-independent:<br/>vertices are duplicated whenever two or more selected wedge or face attributes do not match.<br/>This is particularly useful for GPU-friendly mesh layout, where a single index must be used to access all required vertex attributes.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Normal Source: </TD> <TD><i> Choose a method -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Color Source: </TD> <TD><i> Choose a method -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Texcoord Source: </TD> <TD><i> Choose a method -- </i></TD> </TR>
</TABLE>

\section f159 Subdivision Surfaces: LS3 Loop 

Apply LS3 Subdivision Surface algorithm using Loop's weights. This refinement method take normals into account. <br>See:<i>Boye', S. Guennebaud, G. & Schlick, C.</i> <br><b>Least squares subdivision surfaces</b><br>Computer Graphics Forum, 2010.<br/><br/>Alternatives weighting schemes are based on the paper: <i>Barthe, L. & Kobbelt, L.</i><br><b>Subdivision scheme tuning around extraordinary vertices</b><br>Computer Aided Geometric Design, 2004, 21, 561-583.<br/>The current implementation of these schemes don't handle vertices of valence > 12
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Weighting scheme </TD> <TD><i> Change the weights used. Allows one to optimize some behaviors over others. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Iterations </TD> <TD><i> Number of time the model is subdivided. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Edge Threshold </TD> <TD><i> All the edges <b>longer</b> than this threshold will be refined.<br>Setting this value to zero will force an uniform refinement. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selected faces </TD> <TD><i> If selected the filter affect only the selected faces -- </i></TD> </TR>
</TABLE>

\section f160 Compute Planar Section 

Compute the polyline representing a planar section (a slice) of a mesh; if the resulting polyline is closed the result is filled and also a triangular mesh representing the section is saved
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Plane perpendicular to </TD> <TD><i> The Slicing plane will be done perpendicular to the axis -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Custom axis </TD> <TD><i> Specify a custom axis, this is only valid if the above parameter is set to Custom -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Cross plane offset </TD> <TD><i> Specify an offset of the cross-plane. The offset corresponds to the distance from the point specified in the plane reference parameter. By default (Cross plane offset == 0) -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> plane reference </TD> <TD><i> Specify the reference from which the planes are shifted -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Create also section surface </TD> <TD><i> If selected, in addition to a layer with the section polyline, it will be created also a layer with a triangulated version of the section polyline. This only works if the section polyline is closed -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Create also split surfaces </TD> <TD><i> If selected, it will create two layers with the portion of the mesh under and over the section plane. It requires manifoldness of the mesh. -- </i></TD> </TR>
</TABLE>

\section f161 Create Selection Perimeter Polyline 

Create a new Layer with the perimeter polyline(s) of the selection borders
<H2> Parameters </h2>
No parameters.<br>
\section f162 MLS projection (RIMLS) 

Project a mesh (or a point set) onto the MLS surface defined by itself or another point set.<br><br>This is the Robust Implicit MLS (RIMLS) variant which is an extension of Implicit MLS preserving sharp features using non linear regression. For more details see: <br>Oztireli, Guennebaud and Gross, 'Feature Preserving Point Set Surfaces based on Non-Linear Kernel Regression' Eurographics 2009.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Point set </TD> <TD><i> The point set (or mesh) which defines the MLS surface. -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Proxy Mesh </TD> <TD><i> The mesh that will be projected/resampled onto the MLS surface. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Selection only </TD> <TD><i> If checked, only selected vertices will be projected. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Filter scale </TD> <TD><i> Scale of the spatial low pass filter.
It is relative to the radius (local point spacing) of the vertices. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Projection - Accuracy (adv) </TD> <TD><i> Threshold value used to stop the projections.
This value is scaled by the mean point spacing to get the actual threshold. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Projection - Max iterations (adv) </TD> <TD><i> Max number of iterations for the projection. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Sharpness </TD> <TD><i> Width of the filter used by the normal refitting weight.This weight function is a Gaussian on the distance between two unit vectors:the current gradient and the input normal. Therefore, typical value range between 0.5 (sharp) to 2 (smooth). -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> MLS - Max fitting iterations </TD> <TD><i> Max number of fitting iterations. (0 or 1 is equivalent to the standard IMLS) -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Refinement - Max subdivisions </TD> <TD><i> Max number of subdivisions. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Refinement - Crease angle (degree) </TD> <TD><i> Threshold angle between two faces controlling the refinement. -- </i></TD> </TR>
</TABLE>

\section f163 MLS projection (APSS) 

Project a mesh (or a point set) onto the MLS surface defined by itself or another point set.<br><br>This is the <i>algebraic point set surfaces</i> (APSS) variant which is based on the local fitting of algebraic spheres. It requires points equipped with oriented normals. <br>For all the details about APSS see: <br> Guennebaud and Gross, 'Algebraic Point Set Surfaces', Siggraph 2007, and<br>Guennebaud et al., 'Dynamic Sampling and Rendering of APSS', Eurographics 2008
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Point set </TD> <TD><i> The point set (or mesh) which defines the MLS surface. -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Proxy Mesh </TD> <TD><i> The mesh that will be projected/resampled onto the MLS surface. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Selection only </TD> <TD><i> If checked, only selected vertices will be projected. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Filter scale </TD> <TD><i> Scale of the spatial low pass filter.
It is relative to the radius (local point spacing) of the vertices. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Projection - Accuracy (adv) </TD> <TD><i> Threshold value used to stop the projections.
This value is scaled by the mean point spacing to get the actual threshold. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Projection - Max iterations (adv) </TD> <TD><i> Max number of iterations for the projection. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Spherical parameter </TD> <TD><i> Control the curvature of the fitted spheres: 0 is equivalent to a pure plane fit,1 to a pure spherical fit, values between 0 and 1 gives intermediate results,while other real values might give interesting results, but take care with extremesettings ! -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Accurate normals </TD> <TD><i> If checked, use the accurate MLS gradient instead of the local approximationto compute the normals. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Refinement - Max subdivisions </TD> <TD><i> Max number of subdivisions. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Refinement - Crease angle (degree) </TD> <TD><i> Threshold angle between two faces controlling the refinement. -- </i></TD> </TR>
</TABLE>

\section f164 Marching Cubes (RIMLS) 

Extract the iso-surface (as a mesh) of a MLS surface defined by the current point set (or mesh)using the marching cubes algorithm. The coarse extraction is followed by an accurate projectionstep onto the MLS, and an extra zero removal procedure.<br><br>This is the Robust Implicit MLS (RIMLS) variant which is an extension of Implicit MLS preserving sharp features using non linear regression. For more details see: <br>Oztireli, Guennebaud and Gross, 'Feature Preserving Point Set Surfaces based on Non-Linear Kernel Regression' Eurographics 2009.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> MLS - Filter scale </TD> <TD><i> Scale of the spatial low pass filter.
It is relative to the radius (local point spacing) of the vertices. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Projection - Accuracy (adv) </TD> <TD><i> Threshold value used to stop the projections.
This value is scaled by the mean point spacing to get the actual threshold. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Projection - Max iterations (adv) </TD> <TD><i> Max number of iterations for the projection. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Sharpness </TD> <TD><i> Width of the filter used by the normal refitting weight.This weight function is a Gaussian on the distance between two unit vectors:the current gradient and the input normal. Therefore, typical value range between 0.5 (sharp) to 2 (smooth). -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> MLS - Max fitting iterations </TD> <TD><i> Max number of fitting iterations. (0 or 1 is equivalent to the standard IMLS) -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Grid Resolution </TD> <TD><i> The resolution of the grid on which we run the marching cubes.This marching cube is memory friendly, so you can safely set large values up to 1000 or even more. -- </i></TD> </TR>
</TABLE>

\section f165 Marching Cubes (APSS) 

Extract the iso-surface (as a mesh) of a MLS surface defined by the current point set (or mesh)using the marching cubes algorithm. The coarse extraction is followed by an accurate projectionstep onto the MLS, and an extra zero removal procedure.<br><br>This is the <i>algebraic point set surfaces</i> (APSS) variant which is based on the local fitting of algebraic spheres. It requires points equipped with oriented normals. <br>For all the details about APSS see: <br> Guennebaud and Gross, 'Algebraic Point Set Surfaces', Siggraph 2007, and<br>Guennebaud et al., 'Dynamic Sampling and Rendering of APSS', Eurographics 2008
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> MLS - Filter scale </TD> <TD><i> Scale of the spatial low pass filter.
It is relative to the radius (local point spacing) of the vertices. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Projection - Accuracy (adv) </TD> <TD><i> Threshold value used to stop the projections.
This value is scaled by the mean point spacing to get the actual threshold. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Projection - Max iterations (adv) </TD> <TD><i> Max number of iterations for the projection. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Spherical parameter </TD> <TD><i> Control the curvature of the fitted spheres: 0 is equivalent to a pure plane fit,1 to a pure spherical fit, values between 0 and 1 gives intermediate results,while other real values might give interesting results, but take care with extremesettings ! -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Accurate normals </TD> <TD><i> If checked, use the accurate MLS gradient instead of the local approximationto compute the normals. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Grid Resolution </TD> <TD><i> The resolution of the grid on which we run the marching cubes.This marching cube is memory friendly, so you can safely set large values up to 1000 or even more. -- </i></TD> </TR>
</TABLE>

\section f166 Colorize curvature (RIMLS) 

Colorize the vertices of a mesh or point set using the curfvature of the underlying surface.<br><br>This is the Robust Implicit MLS (RIMLS) variant which is an extension of Implicit MLS preserving sharp features using non linear regression. For more details see: <br>Oztireli, Guennebaud and Gross, 'Feature Preserving Point Set Surfaces based on Non-Linear Kernel Regression' Eurographics 2009.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Selection only </TD> <TD><i> If checked, only selected vertices will be projected. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Filter scale </TD> <TD><i> Scale of the spatial low pass filter.
It is relative to the radius (local point spacing) of the vertices. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Projection - Accuracy (adv) </TD> <TD><i> Threshold value used to stop the projections.
This value is scaled by the mean point spacing to get the actual threshold. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Projection - Max iterations (adv) </TD> <TD><i> Max number of iterations for the projection. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Sharpness </TD> <TD><i> Width of the filter used by the normal refitting weight.This weight function is a Gaussian on the distance between two unit vectors:the current gradient and the input normal. Therefore, typical value range between 0.5 (sharp) to 2 (smooth). -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> MLS - Max fitting iterations </TD> <TD><i> Max number of fitting iterations. (0 or 1 is equivalent to the standard IMLS) -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Curvature type </TD> <TD><i> The type of the curvature to plot. -- </i></TD> </TR>
</TABLE>

\section f167 Colorize curvature (APSS) 

Colorize the vertices of a mesh or point set using the curfvature of the underlying surface.<br><br>This is the <i>algebraic point set surfaces</i> (APSS) variant which is based on the local fitting of algebraic spheres. It requires points equipped with oriented normals. <br>For all the details about APSS see: <br> Guennebaud and Gross, 'Algebraic Point Set Surfaces', Siggraph 2007, and<br>Guennebaud et al., 'Dynamic Sampling and Rendering of APSS', Eurographics 2008
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Selection only </TD> <TD><i> If checked, only selected vertices will be projected. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Filter scale </TD> <TD><i> Scale of the spatial low pass filter.
It is relative to the radius (local point spacing) of the vertices. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Projection - Accuracy (adv) </TD> <TD><i> Threshold value used to stop the projections.
This value is scaled by the mean point spacing to get the actual threshold. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Projection - Max iterations (adv) </TD> <TD><i> Max number of iterations for the projection. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> MLS - Spherical parameter </TD> <TD><i> Control the curvature of the fitted spheres: 0 is equivalent to a pure plane fit,1 to a pure spherical fit, values between 0 and 1 gives intermediate results,while other real values might give interesting results, but take care with extremesettings ! -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Curvature type </TD> <TD><i> The type of the curvature to plot.<br>ApproxMean uses the radius of the fitted sphere as an approximation of the mean curvature. -- </i></TD> </TR>
</TABLE>

\section f168 Estimate radius from density 

Estimate the local point spacing (aka radius) around each vertex using a basic estimate of the local density.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Number of neighbors </TD> <TD><i> Number of neighbors used to estimate the local density. Larger values lead to smoother variations. -- </i></TD> </TR>
</TABLE>

\section f169 Select small disconnected component 

Select the small disconnected components of a mesh.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Small component ratio </TD> <TD><i> This ratio (between 0 and 1) defines the meaning of <i>small</i> as the threshold ratio between the number of facesof the largest component and the other ones. A larger value will select more components. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Select only non closed components </TD> <TD><i>  -- </i></TD> </TR>
</TABLE>

\section f170 Image Registration: Global refinement using Mutual Information 

Calculate a global refinement of image registration, in order to obtain a better alignment of fine detail. It will refine only the shots associated to the active rasters, the non-active ones will be used but not refined. This filter is an implementation of Dellepiane et al. 'Global refinement of image-to-geometry registration for color projection', 2013, and it was used in Corsini et al 'Fully Automatic Registration of Image Sets on Approximate Geometry', 2013. Please cite!
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Rendering mode: </TD> <TD><i> Rendering modes -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Maximum number of minimizations step </TD> <TD><i> Maximum number of minimizations step on the global graph -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Threshold for refinement convergence (in pixels) </TD> <TD><i> The threshold (average quadratic variation in the projection on image plane of some samples of the mesh before and after each step of refinement) that stops the refinement -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Pre-alignment step </TD> <TD><i> Pre-alignment step -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Estimate focal length </TD> <TD><i> Estimate focal length -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Fine Alignment </TD> <TD><i> Fine alignment -- </i></TD> </TR>
</TABLE>

\section f171 Image alignment: Mutual Information 

Register an image on a 3D model using Mutual Information. This filter is an implementation of Corsini et al. 'Image-to-geometry registration: a mutual information method exploiting illumination-related geometric properties', 2009, <a href="http://vcg.isti.cnr.it/Publications/2009/CDPS09/" target="_blank">Get link</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Rendering mode: </TD> <TD><i> Rendering modes -- </i></TD> </TR>
<TR><TD> \c Shotf  </TD> <TD> Starting shot </TD> <TD><i> If the point of view has been set by hand, it must be retrieved from current trackball -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Estimate focal length </TD> <TD><i> Estimate focal length: if not checked, only extrinsic parameters are estimated -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Fine Alignment </TD> <TD><i> Fine alignment: the perturbations applied to reach the alignment are smaller -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Max iterations </TD> <TD><i> Maximum number of iterations -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Tolerance </TD> <TD><i> Threshold to stop convergence -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Expected Variance </TD> <TD><i> Expected Variance -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Background Weight </TD> <TD><i> Weight of background pixels (1, as all the other pixels; 2, one half of the other pixels etc etc) -- </i></TD> </TR>
</TABLE>

\section f172 Surface Reconstruction: VCG 

The surface reconstrction algorithm that have been used for a long time inside the ISTI-Visual Computer Lab.It is mostly a variant of the Curless et al. e.g. a volumetric approach with some original weighting schemes,a different expansion rule, and another approach to hole filling through volume dilation/relaxations.<br>The filter is applied to <b>ALL</b> the visible layers. In practice, all the meshes/point clouds that are currently <i>visible<i> are used to build the volumetric distance field.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Voxel Side </TD> <TD><i> VoxelSide -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> SubVol Splitting </TD> <TD><i> The level of recursive splitting of the subvolume reconstruction process. A value of '3' means that a 3x3x3 regular space subdivision is created and the reconstruction process generate 8 matching meshes. It is useful for reconsruction objects at a very high resolution. Default value (1) means no splitting. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Geodesic Weighting </TD> <TD><i> The influence of each range map is weighted with its geodesic distance from the borders. In this way when two (or more ) range maps overlaps their contribution blends smoothly hiding possible misalignments.  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Show Result </TD> <TD><i> if not checked the result is only saved into the current directory -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Volume Laplacian iter </TD> <TD><i> How many volume smoothing step are performed to clean out the eventually noisy borders -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Widening </TD> <TD><i>  How many voxel the field is expanded. Larger this value more holes will be filled -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Vertex Splatting </TD> <TD><i> This option use a different way to build up the volume, instead of using rasterization of the triangular face it splat the vertices into the grids. It works under the assumption that you have at least one sample for each voxel of your reconstructed volume. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Post Merge simplification </TD> <TD><i> After the merging an automatic simplification step is performed. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> PreSmooth iter </TD> <TD><i> How many times, before converting meshes into volume, the normal of the surface are smoothed. It is useful only to get more smooth expansion in case of noisy borders. -- </i></TD> </TR>
</TABLE>

\section f173 Simplfication: Edge Collapse for Marching Cube meshes 

A simplification/cleaning algorithm that works ONLY on meshes generated by Marching Cubes algorithm.
<H2> Parameters </h2>
No parameters.<br>
\section f174 Convex Hull 

Calculate the <b>convex hull</b> with Qhull library (http://www.qhull.org/html/qconvex.htm).<br><br> The convex hull of a set of points is the boundary of the minimal convex set containing the given non-empty finite set of points.
<H2> Parameters </h2>
No parameters.<br>
\section f175 Delaunay Triangulation 

Calculate the <b>Delaunay triangulation</b> with Qhull library (http://www.qhull.org/html/qdelaun.htm).<br><br>The Delaunay triangulation DT(P) of a set of points P in d-dimensional spaces is a triangulation of the convex hull such that no point in P is inside the circum-sphere of any simplex in DT(P).<br> 
<H2> Parameters </h2>
No parameters.<br>
\section f176 Voronoi Filtering 

Compute a <b>Voronoi filtering</b> (Amenta and Bern 1998) with Qhull library (http://www.qhull.org/). <br><br>The algorithm calculates a triangulation of the input point cloud without requiring vertex normals.It uses a subset of the Voronoi vertices to remove triangles from the Delaunay triangulation. <br>After computing the Voronoi diagram, foreach sample point it chooses the two farthest opposite Voronoi vertices.Then computes a Delaunay triangulation of the sample points and the selected Voronoi vertices, and keep only those triangles in witch all three vertices are sample points.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> Pole Discard Thr </TD> <TD><i> Threshold used to discard the Voronoi vertices too far from the origin.We discard vertices are further than this factor times the bbox diagonal <br>Growing values of this value will add more Voronoi vertices for a better tightier surface reconstruction.On the other hand they will increase processing time and could cause numerical problems to the qhull library.<br> -- </i></TD> </TR>
</TABLE>

\section f177 Alpha Complex/Shape 

Calculate the <b>Alpha Shape</b> of the mesh(Edelsbrunner and P.Mucke 1994) with Qhull library (http://www.qhull.org/). <br><br>From a given finite point set in the space it computes 'the shape' of the set.The Alpha Shape is the boundary of the alpha complex, that is a subcomplex of the Delaunay triangulation of the given point set.<br>For a given value of 'alpha', the alpha complex includes all the simplices in the Delaunay triangulation which have an empty circumsphere with radius equal or smaller than 'alpha'.<br>The filter inserts the minimum value of alpha (the circumradius of the triangle) in attribute Quality foreach face.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Alpha value </TD> <TD><i> Compute the alpha value as percentage of the diagonal of the bbox -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Get: </TD> <TD><i> Select the output. The Alpha Shape is the boundary of the Alpha Complex -- </i></TD> </TR>
</TABLE>

\section f178 Select Visible Points 

Select the <b>visible points</b> in a point cloud, as viewed from a given viewpoint.<br>It uses the Qhull library (http://www.qhull.org/ <br><br>The algorithm used (Katz, Tal and Basri 2007) determines visibility without reconstructing a surface or estimating normals.A point is considered visible if its transformed point lies on the convex hull of a trasformed points cloud from the original mesh points.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> radius threshold  </TD> <TD><i> Bounds the radius of the sphere used to select visible points.It is used to adjust the radius of the sphere (calculated as distance between the center and the farthest point from it) according to the following equation: <br>radius = radius * pow(10,threshold); <br>As the radius increases more points are marked as visible.Use a big threshold for dense point clouds, a small one for sparse clouds. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use ViewPoint from Mesh Camera </TD> <TD><i> Uses the ViewPoint from the camera associated to the current mesh
 if there is no camera, an error occurs -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> ViewPoint </TD> <TD><i> if UseCamera is true, this value is ignored -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Show Partial Convex Hull of flipped points </TD> <TD><i> Show Partial Convex Hull of the transformed point cloud -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Show a triangulation of the visible points </TD> <TD><i> Show a triangulation of the visible points -- </i></TD> </TR>
</TABLE>

\section f179 Quality Mapper applier 

The filter maps quality levels into colors using a colorband built from a transfer function (may be loaded from an external file) and colorizes the mesh vertices. The minimum, medium and maximum quality values can be set by user to obtain a custom quality range for mapping
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Minimum mesh quality </TD> <TD><i> The specified quality value is mapped in the <b>lower</b> end of the chosen color scale. Default value: the minimum quality value found on the mesh. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Maximum mesh quality </TD> <TD><i> The specified quality value is mapped in the <b>upper</b> end of the chosen color scale. Default value: the maximum quality value found on the mesh. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Gamma biasing (0..100) </TD> <TD><i> Defines a gamma compression of the quality values, by setting the position of the middle of the color scale. Value is defined as a percentage (0..100). Default value is 50, that corresponds to a linear mapping. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Mesh brightness </TD> <TD><i> must be between 0 and 2. 0 represents a completely dark mesh, 1 represents a mesh colorized with original colors, 2 represents a completely bright mesh -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Transfer Function type to apply to filter </TD> <TD><i> Choose the Transfer Function to apply to the filter -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Custom TF Filename </TD> <TD><i> Filename of the transfer function to be loaded, used only if you have chosen the Custom Transfer Function. Write the full path of the qmap file, or save the file in the same folder of the current mesh, and write only the name of the qmap file. Only the RGB mapping will be imported from the qmap file -- </i></TD> </TR>
</TABLE>

\section f180 Random Vertex Displacement 

Move the vertices of the mesh of a random quantity.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Recompute normals </TD> <TD><i> Toggle the recomputation of the normals after the random displacement.

If disabled the face normals will remains unchanged resulting in a visually pleasant effect. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Max displacement </TD> <TD><i> The vertex are displaced of a vector whose norm is bounded by this value -- </i></TD> </TR>
</TABLE>

\section f181 Vertex Color Noise 

Randomly add a small amount of a random base color to the mesh
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Color  </TD> <TD> BaseColor </TD> <TD><i> The base color that is added to the mesh. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Alpha </TD> <TD><i> The random color is blended with the current one with the specified alpha -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Noisy Frequency </TD> <TD><i> The frequency of the Noise on the mesh. Higher numbers means smaller spots. -- </i></TD> </TR>
</TABLE>

\section f182 GPU Filter Example  

Small useless filter added only to show how to work with a gl render context inside a filter.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Color  </TD> <TD> Image Background Color </TD> <TD><i> The color used as image background. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Image Width </TD> <TD><i> The width in pixels of the produced image. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Image Height </TD> <TD><i> The height in pixels of the produced image. -- </i></TD> </TR>
<TR><TD> \c FileName  </TD> <TD> Base Image File Name </TD> <TD><i> The file name used to save the image. -- </i></TD> </TR>
</TABLE>

\section f183 Mesh Element Sampling 

Create a new layer populated with a point sampling of the current mesh; at most one sample for each element of the mesh is created. Samples are taking in a uniform way, one for each element (vertex/edge/face); all the elements have the same probability of being chosen.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Element to sample: </TD> <TD><i> Choose what mesh element has to be used for the subsampling. At most one point sample will be added for each one of the chosen elements -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Number of samples </TD> <TD><i> The desired number of elements that must be chosen. Being a subsampling of the original elements if this number should not be larger than the number of elements of the original mesh. -- </i></TD> </TR>
</TABLE>

\section f184 Montecarlo Sampling 

Create a new layer populated with a point sampling of the current mesh; samples are generated in a randomly uniform way, or with a distribution biased by the per-vertex quality values of the mesh.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Number of samples </TD> <TD><i> The desired number of samples. It can be smaller or larger than the mesh size, and according to the chosen sampling strategy it will try to adapt. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Quality Weighted Sampling </TD> <TD><i> Use per vertex quality to drive the vertex sampling. The number of samples falling in each face is proportional to the face area multiplied by the average quality of the face vertices. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Per-Face Normal </TD> <TD><i> If true for each sample we take the normal of the sampled face, otherwise the normal interpolated from the vertex normals. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Radius Variance </TD> <TD><i> The radius of the disk is allowed to vary between r/var and r*var. If this parameter is 1 the sampling is the same of the Poisson Disk Sampling -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Exact Sample Number </TD> <TD><i> If the required total number of samples is not a strict exact requirement we can exploit a different algorithmbased on the choice of the number of samples inside each triangle by a random Poisson-distributed number with mean equal to the expected number of samples times the area of the triangle over the surface of the whole mesh. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Sample CreaseEdge Only </TD> <TD><i> Restrict the sampling process to the crease edges only. Useful to sample in a more accurate way the feature edges of a mechanical mesh. -- </i></TD> </TR>
</TABLE>

\section f185 Stratified Triangle Sampling 

Create a new layer populated with a point sampling of the current mesh; to generate multiple samples inside a triangle each triangle is subdivided according to various <i>stratified</i> strategies. Distribution is often biased by triangle shape.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Number of samples </TD> <TD><i> The desired number of samples. It can be smaller or larger than the mesh size, and according to the chosen sampling strategy it will try to adapt. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Element to sample: </TD> <TD><i> <b>Similar Triangle</b>: each triangle is subdivided into similar triangles and the internal vertices of these triangles are considered. This sampling leave space around edges and vertices for separate sampling of these entities.<br><b>Dual Similar Triangle</b>: each triangle is subdivided into similar triangles and the internal vertices of these triangles are considered.  <br><b>Long Edge Subdiv</b> each triangle is recursively subdivided along the longest edge. <br><b>Sample Edges</b> Only the edges of the mesh are uniformly sampled. <br><b>Sample NonFaux Edges</b> Only the non-faux edges of the mesh are uniformly sampled. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Random Sampling </TD> <TD><i> if true, for each (virtual) face we draw a random point, otherwise we pick the face midpoint. -- </i></TD> </TR>
</TABLE>

\section f186 Clustered Vertex Sampling 

Create a new layer populated with a subsampling of the vertices of the current mesh; the subsampling is driven by a simple one-per-gridded cell strategy.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Cell Size </TD> <TD><i> The size of the cell of the clustering grid. Smaller the cell finer the resulting mesh. For obtaining a very coarse mesh use larger values. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Representative Strategy: </TD> <TD><i> <b>Average</b>: for each cell we take the average of the sample falling into. The resulting point is a new point.<br><b>Closest to center</b>: for each cell we take the sample that is closest to the center of the cell. Chosen vertices are a subset of the original ones. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on Selection </TD> <TD><i> If true only for the filter is applied only on the selected subset of the mesh. -- </i></TD> </TR>
</TABLE>

\section f187 Poisson-disk Sampling 

Create a new layer populated with a point sampling of the current mesh;samples are generated according to a Poisson-disk distribution, using the algorithm described in:<br><b>'Efficient and Flexible Sampling with Blue Noise Properties of Triangular Meshes'</b><br> Massimiliano Corsini, Paolo Cignoni, Roberto Scopigno<br>IEEE TVCG 2012
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Number of samples </TD> <TD><i> The desired number of samples. The ray of the disk is calculated according to the sampling density. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Explicit Radius </TD> <TD><i> If not zero this parameter override the previous parameter to allow exact radius specification -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> MonterCarlo OverSampling </TD> <TD><i> The over-sampling rate that is used to generate the initial Montecarlo samples (e.g. if this parameter is <i>K</i> means that<i>K</i> x <i>poisson sample</i> points will be used). The generated Poisson-disk samples are a subset of these initial Montecarlo samples. Larger this number slows the process but make it a bit more accurate. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Save Montecarlo </TD> <TD><i> If true, it will generate an additional Layer with the montecarlo sampling that was pruned to build the poisson distribution. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Approximate Geodesic Distance </TD> <TD><i> If true Poisson Disc distances are computed using an approximate geodesic distance, e.g. an euclidean distance weighted by a function of the difference between the normals of the two points. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Base Mesh Subsampling </TD> <TD><i> If true the original vertices of the base mesh are used as base set of points. In this case the SampleNum should be obviously much smaller than the original vertex number.<br>Note that this option is very useful in the case you want to subsample a dense point cloud. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Refine Existing Samples </TD> <TD><i> If true the vertices of the below mesh are used as starting vertices, and they will utterly refined by adding more and more points until possible.  -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Samples to be refined </TD> <TD><i> Used only if the above option is checked.  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Best Sample Heuristic </TD> <TD><i> If true it will use a simple heuristic for choosing the samples. At a small cost (it can slow a bit the process) it usually improve the maximality of the generated sampling.  -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Best Sample Pool Size </TD> <TD><i> Used only if the Best Sample Flag is true. It control the number of attempt that it makes to get the best sample. It is reasonable that it is smaller than the Montecarlo oversampling factor. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Exact number of samples </TD> <TD><i> If requested it will try to do a dicotomic search for the best poisson disk radius that will generate the requested number of samples with a tolerance of the 0.5%. Obviously it takes much longer. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Radius Variance </TD> <TD><i> The radius of the disk is allowed to vary between r and r*var. If this parameter is 1 the sampling is the same of the Poisson Disk Sampling -- </i></TD> </TR>
</TABLE>

\section f188 Hausdorff Distance 

Compute the Hausdorff Distance between two layers, sampling one of the two and finding for each sample the closest point over the other mesh.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Sampled Mesh </TD> <TD><i> The mesh whose surface is sampled. For each sample we search the closest point on the Target Mesh. -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Target Mesh </TD> <TD><i> The mesh that is sampled for the comparison. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Save Samples </TD> <TD><i> Save the position and distance of all the used samples on both the two surfaces, creating two new layers with two point clouds representing the used samples. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Sample Vertices </TD> <TD><i> For the search of maxima it is useful to sample vertices and edges of the mesh with a greater care. It is quite probably the the farthest points falls along edges or on mesh vertices, and with uniform montecarlo sampling approachesthe probability of taking a sample over a vertex or an edge is theoretically null.<br>On the other hand this kind of sampling could make the overall sampling distribution slightly biased and slightly affects the cumulative results. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Sample Edges </TD> <TD><i> See the above comment. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Sample FauxEdge </TD> <TD><i> See the above comment. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Sample Faces </TD> <TD><i> See the above comment. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Number of samples </TD> <TD><i> The desired number of samples. It can be smaller or larger than the mesh size, and according to the chosen sampling strategy it will try to adapt. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Max Distance </TD> <TD><i> Sample points for which we do not find anything within this distance are rejected and not considered neither for averaging nor for max. -- </i></TD> </TR>
</TABLE>

\section f189 Distance from Reference Mesh 

Compute the signed/unsigned (per vertex) distance between a mesh/pointcloud and a reference mesh/pointcloud. Distance is stored in vertex quality.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Measured Mesh/PointCloud </TD> <TD><i> The Mesh/Pointcloud that is measured, vertex by vertex, computing distance from the REFERENCE mesh/pointcloud. -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Reference Mesh/PointCloud </TD> <TD><i> The Mesh/Pointcloud that is used as a reference, to measure distance from. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Compute Signed Distance </TD> <TD><i> If TRUE, the distance is signed; if FALSE, it will compute the distance absolute value. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Max Distance [abs] </TD> <TD><i> Search is interrupted when nothing is found within this distance range [+maxDistance -maxDistance]. -- </i></TD> </TR>
</TABLE>

\section f190 Texel Sampling 

Create a new layer with a point sampling of the current mesh, a sample for each texel of the mesh is generated
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Texture Width </TD> <TD><i> A sample for each texel is generated, so the desired texture size is need, only samples for the texels falling inside some faces are generated.
 Setting this param to 256 means that you get at most 256x256 = 65536 samples).<br>If this parameter is 0 the size of the current texture is chosen. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Texture Height </TD> <TD><i> A sample for each texel is generated, so the desired texture size is need, only samples for the texels falling inside some faces are generated.
 Setting this param to 256 means that you get at most 256x256 = 65536 samples) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> UV Space Sampling </TD> <TD><i> The generated texel samples have their UV coords as point positions. The resulting point set is has a square domain, the texels/points, even if on a flat domain retain the original vertex normal to help a better perception of the original provenience. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> RecoverColor </TD> <TD><i> The generated point cloud has the current texture color -- </i></TD> </TR>
</TABLE>

\section f191 Vertex Attribute Transfer 

Transfer the chosen per-vertex attributes from one layer to another. Useful to transfer attributes to different representations of a same object.<br>For each vertex of the target mesh the closest point (not vertex!) on the source mesh is computed, and the requested interpolated attributes from that source point are copied into the target vertex.<br>The algorithm assumes that the two meshes are reasonably similar and aligned.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Source Mesh </TD> <TD><i> The mesh that contains the source data that we want to transfer. -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Target Mesh </TD> <TD><i> The mesh whose vertices will receive the data from the source. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Transfer Geometry </TD> <TD><i> if enabled, the position of each vertex of the target mesh will be snapped onto the corresponding closest point on the source mesh -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Transfer Normal </TD> <TD><i> if enabled, the normal of each vertex of the target mesh will get the (interpolated) normal of the corresponding closest point on the source mesh -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Transfer Color </TD> <TD><i> if enabled, the color of each vertex of the target mesh will become the color of the corresponding closest point on the source mesh -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Transfer quality </TD> <TD><i> if enabled, the quality of each vertex of the target mesh will become the quality of the corresponding closest point on the source mesh -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Transfer Selection </TD> <TD><i> if enabled,  each vertex of the target mesh will be selected if the corresponding closest point on the source mesh falls in a selected face -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Store dist. as quality </TD> <TD><i> if enabled, we store the distance of the transferred value as in the vertex quality -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Max Dist Search </TD> <TD><i> Sample points for which we do not find anything within this distance are rejected and not considered for recovering attributes. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Only on selection </TD> <TD><i> If checked, only transfer to selected vertices on TARGET mesh -- </i></TD> </TR>
</TABLE>

\section f192 Uniform Mesh Resampling 

Create a new mesh that is a resampled version of the current one.<br>The resampling is done by building a uniform volumetric representation where each voxel contains the signed distance from the original surface. The resampled surface is reconstructed using the <b>marching cube</b> algorithm over this volume.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Precision </TD> <TD><i> Size of the cell, the default is 1/50 of the box diag. Smaller cells give better precision at a higher computational cost. Remember that halving the cell size means that you build a volume 8 times larger. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Offset </TD> <TD><i> Offset of the created surface (i.e. distance of the created surface from the original one).<br>If offset is zero, the created surface passes on the original mesh itself. Values greater than zero mean an external surface, and lower than zero mean an internal surface.<br> In practice this value is the threshold passed to the Marching Cube algorithm to extract the isosurface from the distance field representation. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Clean Vertices </TD> <TD><i> If true the mesh generated by MC will be cleaned by unifying vertices that are almost coincident -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Discretize </TD> <TD><i> If true the position of the intersected edge of the marching cube grid is not computed by linear interpolation, but it is placed in fixed middle position. As a consequence the resampled object will look severely aliased by a stairstep appearance.<br>Useful only for simulating the output of 3D printing devices. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Multi-sample </TD> <TD><i> If true the distance field is more accurately compute by multisampling the volume (7 sample for each voxel). Much slower but less artifacts. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Absolute Distance </TD> <TD><i> If true a <b> not</b> signed distance field is computed. In this case you have to choose a not zero Offset and a double surface is built around the original surface, inside and outside. Is useful to convrt thin floating surfaces into <i> solid, thick meshes.</i>. t -- </i></TD> </TR>
</TABLE>

\section f193 Voronoi Vertex Coloring 

Given a Mesh <b>M</b> and a Pointset <b>P</b>, The filter project each vertex of P over M and color M according to the geodesic distance from these projected points. Projection and coloring are done on a per vertex basis.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> To be Colored Mesh </TD> <TD><i> The mesh whose surface is colored. For each vertex of this mesh we decide the color according the below parameters. -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Vertex Mesh </TD> <TD><i> The mesh whose vertices are used as seed points for the color computation. These seeds point are projected onto the above mesh. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> BackDistance </TD> <TD><i> If true the mesh is colored according the distance from the frontier of the voonoi diagram induced by the VertexMesh seeds. -- </i></TD> </TR>
</TABLE>

\section f194 Disk Vertex Coloring 

Given a Mesh <b>M</b> and a Pointset <b>P</b>, The filter project each vertex of P over M and color M according to the Euclidean distance from these projected points. Projection and coloring are done on a per vertex basis.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> To be Colored Mesh </TD> <TD><i> The mesh whose surface is colored. For each vertex of this mesh we decide the color according the below parameters. -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Vertex Mesh </TD> <TD><i> The mesh whose vertices are used as seed points for the color computation. These seeds point are projected onto the above mesh. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Radius </TD> <TD><i> the radius of the spheres centered in the VertexMesh seeds  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use sample radius </TD> <TD><i> Use the radius that is stored in each sample of the vertex mesh. Useful for displaing the variable disk sampling results -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use Approximate Geodetic </TD> <TD><i> Use the Approximate Geodetic Metric instead of the Euclidean distance. Approximate geodetic metric uses the normals between the two points to weight the euclidean distance. -- </i></TD> </TR>
</TABLE>

\section f195 Regular Recursive Sampling 

The bbox is recursively partitioned in a octree style, center of bbox are considered, when the center is nearer to the surface than a given thr it is projected on it. It works also for building offsetted samples.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Precision </TD> <TD><i> Size of the cell, the default is 1/50 of the box diag. Smaller cells give better precision at a higher computational cost. Remember that halving the cell size means that you build a volume 8 times larger. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Offset </TD> <TD><i> Offset of the created surface (i.e. distance of the created surface from the original one).<br>If offset is zero, the created surface passes on the original mesh itself. Values greater than zero mean an external surface, and lower than zero mean an internal surface.<br> In practice this value is the threshold passed to the Marching Cube algorithm to extract the isosurface from the distance field representation. -- </i></TD> </TR>
</TABLE>

\section f196 Point Cloud Simplification 

Create a new layer populated with a simplified version of the current point cloud.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Number of samples </TD> <TD><i> The desired number of samples. The ray of the disk is calculated according to the sampling density. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Explicit Radius </TD> <TD><i> If not zero this parameter override the previous parameter to allow exact radius specification -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Best Sample Heuristic </TD> <TD><i> If true it will use a simple heuristic for choosing the samples. At a small cost (it can slow a bit the process) it usually improve the maximality of the generated sampling.  -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Best Sample Pool Size </TD> <TD><i> Used only if the Best Sample Flag is true. It control the number of attempt that it makes to get the best sample. It is reasonable that it is smaller than the Montecarlo oversampling factor. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Exact number of samples </TD> <TD><i> If requested it will try to do a dicotomic search for the best poisson disk radius that will generate the requested number of samples with a tolerance of the 0.5%. Obviously it takes much longer. -- </i></TD> </TR>
</TABLE>

\section f197 Surface Reconstruction: Screened Poisson 

This surface reconstruction algorithm creates watertight surfaces from oriented point sets.<br>The filter uses the original code of Michael Kazhdan and Matthew Bolitho implementing the algorithm described in the following paper:<br><i>Michael Kazhdan, Hugues Hoppe</i>,<br><b>"Screened Poisson surface reconstruction"</b><br>ACM Trans. Graphics, 32(3), 2013<br><br><b>WARNING:</b> this filter saves intermediate cache files in the "working" folder (last folder used when loading/saving). Be sure you are not working in a READ-ONLY location.<br>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Merge all visible layers </TD> <TD><i> Enabling this flag means that all the visible layers will be used for providing the points. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Reconstruction Depth </TD> <TD><i> This integer is the maximum depth of the tree that will be used for surface reconstruction. Running at depth d corresponds to solving on a voxel grid whose resolution is no larger than 2^d x 2^d x 2^d. Note that since the reconstructor adapts the octree to the sampling density, the specified reconstruction depth is only an upper bound. The default value for this parameter is 8. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Adaptive Octree Depth </TD> <TD><i> This integer specifies the depth beyond depth the octree will be adapted. At coarser depths, the octree will be complete, containing all 2^d x 2^d x 2^d nodes. The default value for this parameter is 5. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Conjugate Gradients Depth </TD> <TD><i> This integer is the depth up to which a conjugate-gradients solver will be used to solve the linear system. Beyond this depth Gauss-Seidel relaxation will be used. The default value for this parameter is 0. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Scale Factor </TD> <TD><i> This floating point value specifies the ratio between the diameter of the cube used for reconstruction and the diameter of the samples' bounding cube. The default value is 1.1. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Minimum Number of Samples </TD> <TD><i> This floating point value specifies the minimum number of sample points that should fall within an octree node as the octree construction is adapted to sampling density. For noise-free samples, small values in the range [1.0 - 5.0] can be used. For more noisy samples, larger values in the range [15.0 - 20.0] may be needed to provide a smoother, noise-reduced, reconstruction. The default value is 1.5. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Interpolation Weight </TD> <TD><i> This floating point value specifies the importants that interpolation of the point samples is given in the formulation of the screened Poisson equation. The results of the original (unscreened) Poisson Reconstruction can be obtained by setting this value to 0. The default value for this parameter is 4. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Gauss-Seidel Relaxations </TD> <TD><i> This integer value specifies the number of Gauss-Seidel relaxations to be performed at each level of the hierarchy. The default value for this parameter is 8. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Confidence Flag </TD> <TD><i> Enabling this flag tells the reconstructor to use the quality as confidence information; this is done by scaling the unit normals with the quality values. When the flag is not enabled, all normals are normalized to have unit-length prior to reconstruction. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Pre-Clean </TD> <TD><i> Enabling this flag force a cleaning pre-pass on the data removing all unreferenced vertices or vertices with null normals. -- </i></TD> </TR>
</TABLE>

\section f198 Shape Diameter Function 

Calculate the SDF (<b>shape diameter function</b>) on the mesh, you can visualize the result colorizing the mesh. The SDF is a scalar function on the mesh surface and represents the neighborhood diameter of the object at each point. Given a point on the mesh surface,several rays are sent inside a cone, centered around the point's inward-normal, to the other side of the mesh. The result is a weighted sum of all rays lengths. For further details, see the reference paper:<br><b>Shapira Shamir Cohen-Or,<br>Consistent Mesh Partitioning and Skeletonisation using the shaper diamter function, Visual Comput. J. (2008)</b> 
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Metric: </TD> <TD><i> Choose whether to trace rays from faces or from vertices.  -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Number of rays:  </TD> <TD><i> The number of rays that will be casted around the normals. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Depth texture size </TD> <TD><i> Size of the depth texture for depth peeling. Higher resolutions provide better sampling of the mesh, with a small performance penalty. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Peeling Iteration </TD> <TD><i> Number of depth peeling iteration. Actually is the maximum number of layers that a ray can hit while traversing the mesh. For example, in the case of a sphere, you should specify 2 in this parameter. For a torus, specify 4. <b>For more complex geometry you should run the depth complexity filter to know the exact value</b>. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Peeling Tolerance </TD> <TD><i> Depth tolerance used during depth peeling. This is the threshold used to differentiate layers between each others.Two elements whose distance is below this value will be considered as belonging to the same layer. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Cone amplitude </TD> <TD><i> Cone amplitude around normals in degrees. Rays are traced within this cone. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Remove false intersections </TD> <TD><i> For eachray we check the normal at the point of intersection,and ignore intersections where the normal at the intersectionpoints is in the same direction as the point-of-origin(the same direction is defined as an angle difference lessthan 90)  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Remove outliers </TD> <TD><i> The outliers removal is made on the fly with a supersampling of the depth buffer. For each ray that we trace, we take multiple depth values near the point of intersection and we output only the median of these values. Some mesh can benefit from this additional calculation.  -- </i></TD> </TR>
</TABLE>

\section f199 Depth complexity 

Calculate the depth complexity of the mesh, that is: the maximum number of layers that a ray can hit while traversing the mesh. To have a correct value, you should specify and high value in the peeling iteration parameter. You can read the result in the MeshLab log window. <b>If warnings are not present, you have the exact value, otherwise try increasing the peeling iteration parameter. After having calculated the correct value,you can ignore further warnings that you may get using that value.</b>. 
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Metric: </TD> <TD><i> Choose whether to trace rays from faces or from vertices.  -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Number of rays:  </TD> <TD><i> The number of rays that will be casted around the normals. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Depth texture size </TD> <TD><i> Size of the depth texture for depth peeling. Higher resolutions provide better sampling of the mesh, with a small performance penalty. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Peeling Iteration </TD> <TD><i> Number of depth peeling iteration. Actually is the maximum number of layers that a ray can hit while traversing the mesh. For example, in the case of a sphere, you should specify 2 in this parameter. For a torus, specify 4. <b>For more complex geometry you should run the depth complexity filter to know the exact value</b>. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Peeling Tolerance </TD> <TD><i> Depth tolerance used during depth peeling. This is the threshold used to differentiate layers between each others.Two elements whose distance is below this value will be considered as belonging to the same layer. -- </i></TD> </TR>
</TABLE>

\section f200 Volumetric obscurance 

Calculates obscurance coefficients for the mesh. Obscurance is introduced to avoid the disadvantages of both classical ambient term and ambient occlusion. In ambient occlusion, totally occluded parts of the mesh are black. Instead obscurance, despite still based on a perfectly diffuse light coming from everywhere, accounts for multiple bounces of indirect illumination by means of a function of both the openness of a point and the distance to his occluder (if any). Obscurance is inversely proportional to the number of ray casted from the point that hit an occluder and proportional to the distance a ray travels before hitting the occluder. You can control how much the distance factor influences the final result with the obscurance exponenent (see help below). Obscurance is a value in the range [0,1]. For further details see the reference paper:<br><b>Iones Krupkin Sbert Zhukov <br> Fast, Realistic Lighting for Video Games <br>IEEECG&A 2003</b> 
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Metric: </TD> <TD><i> Choose whether to trace rays from faces or from vertices.  -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Number of rays:  </TD> <TD><i> The number of rays that will be casted around the normals. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Depth texture size </TD> <TD><i> Size of the depth texture for depth peeling. Higher resolutions provide better sampling of the mesh, with a small performance penalty. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Peeling Iteration </TD> <TD><i> Number of depth peeling iteration. Actually is the maximum number of layers that a ray can hit while traversing the mesh. For example, in the case of a sphere, you should specify 2 in this parameter. For a torus, specify 4. <b>For more complex geometry you should run the depth complexity filter to know the exact value</b>. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Peeling Tolerance </TD> <TD><i> Depth tolerance used during depth peeling. This is the threshold used to differentiate layers between each others.Two elements whose distance is below this value will be considered as belonging to the same layer. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Cone amplitude </TD> <TD><i> Cone amplitude around normals in degrees. Rays are traced within this cone. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Obscurance Exponent </TD> <TD><i> This parameter controls the spatial decay term in the obscurance formula. The greater the exponent, the greater the influence of distance; that is: even if a ray is blocked by an occluder its contribution to the obscurance term is non zero, but proportional to this parameter. It turs out that if you choose a value of zero, you get the standard ambient occlusion term. <b>(In this case, only a value of two, in the peeling iteration parameter, has a sense)</b> -- </i></TD> </TR>
</TABLE>

\section f201 Select All 

Select all the faces/vertices of the current mesh.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Select all Faces </TD> <TD><i> If true the filter will select all the faces. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Select all Vertices </TD> <TD><i> If true the filter will select all the vertices. -- </i></TD> </TR>
</TABLE>

\section f202 Select None 

Clear the current set of selected faces/vertices.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> De-select all Faces </TD> <TD><i> If true the filter will de-select all the faces. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> De-select all Vertices </TD> <TD><i> If true the filter will de-select all the vertices. -- </i></TD> </TR>
</TABLE>

\section f203 Select Faces by view angle 

Select faces according to the angle between their normal and the view direction. It is used in range map processing to select and delete steep faces parallel to viewdirection.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> angle threshold (deg) </TD> <TD><i> faces with normal at higher angle w.r.t. the view direction are selected -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Use ViewPoint from Mesh Camera </TD> <TD><i> Uses the ViewPoint from the camera associated to the current mesh
 if there is no camera, an error occurs -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> ViewPoint </TD> <TD><i> if UseCamera is true, this value is ignored -- </i></TD> </TR>
</TABLE>

\section f204 Select 'problematic' faces 

Select faces with 'problems', like normal inverted w.r.t the surrounding areas, or extremely elongated
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> select by Aspect Ratio </TD> <TD><i> if true, faces with aspect ratio below the limit will be selected -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Aspect Ratio </TD> <TD><i> Triangle face aspect ratio [1 (equilateral) - 0 (line)]: face will be selected if BELOW this threshold -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> select by Normal Angle </TD> <TD><i> if true, adjacent faces with normals forming an angle above the limit will be selected -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Angle flip </TD> <TD><i> angle between the adjacent faces: face will be selected if ABOVE this threshold -- </i></TD> </TR>
</TABLE>

\section f205 Delete Selected Vertices 

Delete the current set of selected vertices; faces that share one of the deleted vertices are deleted too.
<H2> Parameters </h2>
No parameters.<br>
\section f206 Delete ALL Faces 

Delete ALL faces, turning the mesh into a pointcloud. May be applied also to all visible layers.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Apply to all visible Layers </TD> <TD><i> If selected, the filter will be applied to all visible mesh Layers. -- </i></TD> </TR>
</TABLE>

\section f207 Delete Selected Faces 

Delete the current set of selected faces, vertices that remains unreferenced are not deleted.
<H2> Parameters </h2>
No parameters.<br>
\section f208 Delete Selected Faces and Vertices 

Delete the current set of selected faces and all the vertices surrounded by that faces.
<H2> Parameters </h2>
No parameters.<br>
\section f209 Select Faces from Vertices 

Select faces from selected vertices.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Strict Selection </TD> <TD><i> If true only the faces with <b>all</b> selected vertices are selected. Otherwise any face with at least one selected vertex will be selected. -- </i></TD> </TR>
</TABLE>

\section f210 Select Vertices from Faces 

Select vertices from selected faces.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Strict Selection </TD> <TD><i> If true only the vertices with <b>all</b> the incident face selected are selected. Otherwise any vertex with at least one incident selected face will be selected. -- </i></TD> </TR>
</TABLE>

\section f211 Erode Selection 

Erode (reduce) the current set of selected faces.
<H2> Parameters </h2>
No parameters.<br>
\section f212 Dilate Selection 

Dilate (expand) the current set of selected faces.
<H2> Parameters </h2>
No parameters.<br>
\section f213 Select Border 

Select vertices and faces on the boundary.
<H2> Parameters </h2>
No parameters.<br>
\section f214 Invert Selection 

Invert the current set of selected faces/vertices.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Invert Faces </TD> <TD><i> If true the filter will invert the set of selected faces. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Invert Vertices </TD> <TD><i> If true the filter will invert the set of selected vertices. -- </i></TD> </TR>
</TABLE>

\section f215 Select Connected Faces 

Expand the current face selection so that it includes all the faces in the connected components where there is at least a selected face.
<H2> Parameters </h2>
No parameters.<br>
\section f216 Select by Vertex Quality 

Select all the faces/vertices within the specified vertex quality range.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> Min Quality </TD> <TD><i> Minimum acceptable quality value -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Max Quality </TD> <TD><i> Maximum acceptable quality value -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Inclusive Sel. </TD> <TD><i> If true only the faces with <b>all</b> the vertices within the specified range are selected. Otherwise any face with at least one vertex within the range is selected. -- </i></TD> </TR>
</TABLE>

\section f217 Select by Face Quality 

Select all the faces/vertices with within the specified face quality range.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> Min Quality </TD> <TD><i> Minimum acceptable quality value -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Max Quality </TD> <TD><i> Maximum acceptable quality value -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Inclusive Sel. </TD> <TD><i> If true only the vertices with <b>all</b> the adjacent faces within the specified range are selected. Otherwise any vertex with at least one face within the range is selected. -- </i></TD> </TR>
</TABLE>

\section f218 Select Self Intersecting Faces 

Select only self intersecting faces.
<H2> Parameters </h2>
No parameters.<br>
\section f219 Select Vertex Texture Seams 

Colorize only border edges.
<H2> Parameters </h2>
No parameters.<br>
\section f220 Select non Manifold Edges  

Select the faces and the vertices incident on non manifold edges (e.g. edges where more than two faces are incident); note that this function select the components that are related to non manifold edges. The case of non manifold vertices is specifically managed by the pertinent filter.
<H2> Parameters </h2>
No parameters.<br>
\section f221 Select non Manifold Vertices 

Select the non manifold vertices that do not belong to non manifold edges. For example two cones connected by their apex. Vertices incident on non manifold edges are ignored.
<H2> Parameters </h2>
No parameters.<br>
\section f222 Select Faces with edges longer than... 

Select all triangles having an edge with length greater or equal than a given threshold.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> Edge Threshold </TD> <TD><i> All the faces with an edge <b>longer</b> than this threshold will be deleted. Useful for removing long skinny faces obtained by bad triangulation of range maps. -- </i></TD> </TR>
</TABLE>

\section f223 Select Faces by Color 

Select part of the mesh based on its color.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Color  </TD> <TD> Color To Select </TD> <TD><i> Color that you want to be selected. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Pick Color Space </TD> <TD><i> The color space that the sliders will manipulate. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Inclusive Sel. </TD> <TD><i> If true only the faces with <b>all</b> the vertices within the specified range are selected. Otherwise any face with at least one vertex within the range is selected. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Variation from Red or Hue </TD> <TD><i> A float between 0 and 1 that represents the percent variation from this color that will be selected.  For example if the R was 200 and you put 0.1 then any color with R 200+-25.5 will be selected. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Variation from Green or Saturation </TD> <TD><i> A float between 0 and 1 that represents the percent variation from this color that will be selected.  For example if the R was 200 and you put 0.1 then any color with R 200+-25.5 will be selected. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> Variation from Blue or Value </TD> <TD><i> A float between 0 and 1 that represents the percent variation from this color that will be selected.  For example if the R was 200 and you put 0.1 then any color with R 200+-25.5 will be selected. -- </i></TD> </TR>
</TABLE>

\section f224 Select Folded Faces 

Select the folded faces created by the Quadric Edge Collapse decimation. The face is selected if the angle between the face normal and the normal of the best fitting plane of the neighbor vertices is above the selected threshold.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> Angle Threshold </TD> <TD><i> Angle between the face and the best fitting plane of the neighbours vertices. If it is above the threshold the face is selected. -- </i></TD> </TR>
</TABLE>

\section f225 Select Outliers 

Select the vertex classified as outlier using Local Outlier Propabilty measure described in:<br> <b>'LoOP: Local Outlier Probabilities'</b> Kriegel et al.<br>CIKM 2009
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c DynamicFloat  </TD> <TD> Probability </TD> <TD><i> Threshold to select the vertex. The vertex is selected if the LoOP value is above the threshold. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Number of neighbors </TD> <TD><i> Number of neighbours used to compute the LoOP -- </i></TD> </TR>
</TABLE>

\section f226 Export to Sketchfab 

Upload the current layer on Sketchfab. It requires that you have an account and that you set your private API token in the preferences of MeshLab.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> Sketch Fab Code </TD> <TD><i> Mandatory. -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Title </TD> <TD><i> Mandatory. -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Description </TD> <TD><i> Mandatory. A short description of the model that is uploaded. -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Tags </TD> <TD><i> Mandatory. Tags must be separated by a space. Typical tags usually used by MeshLab users: scan, photogrammetry. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Private </TD> <TD><i> This parameter can be true only for PRO account. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Publish </TD> <TD><i> If true the model will be published immediately. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Auto Rotate </TD> <TD><i> If true the model rotated by 90 degree on the X axis to maintain similar default orientation. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Save SketchFab Code </TD> <TD><i> Saves the API SketchFab code into the MeshLab settings, allowing to load it as default value every time you run this filter. -- </i></TD> </TR>
</TABLE>

\section f227 Structure Synth Mesh Creation 

Structure Synth mesh creation based on Eisen Script.
 For further instruction visit http://structuresynth.sourceforge.net/reference.php
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> Eisen Script grammar </TD> <TD><i> Write a grammar according to Eisen Script specification and using the primitives box, sphere, mesh, dot and triangle  -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> seed for random construction </TD> <TD><i> Seed needed to build the mesh -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> set maximum resolution of sphere primitives, it must be included between 1 and 4 </TD> <TD><i> increasing the resolution of the spheres will improve the quality of the mesh  -- </i></TD> </TR>
</TABLE>

\section f228 Parametrization: Voronoi Atlas 

Build an atlased parametrization based on a geodesic voronoi partitioning of the surface and parametrizing each region using Harmonic Mapping. For the  parametrization of the disk like voronoi regions the used method is: <br><b>Ulrich Pinkall, Konrad Polthier</b><br>                                            <i>Computing Discrete Minimal Surfaces and Their Conjugates</i> <br>                                            Experimental Mathematics, Vol 2 (1), 1993<br> .
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Approx. Region Num </TD> <TD><i> An estimation of the number of regions that must be generated. Smaller regions could lead to parametrizations with smaller distortion. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Overlap </TD> <TD><i> If checked the resulting parametrization will be composed by <i>overlapping</i> regions, e.g. the resulting mesh will have duplicated faces: each region will have a ring of ovelapping duplicate faces that will ensure that border regions will be parametrized in the atlas twice. This is quite useful for building mipmap robust atlases -- </i></TD> </TR>
</TABLE>

\section f229 Convert PerWedge UV into PerVertex UV 

Converts per Wedge Texture Coordinates to per Vertex Texture Coordinates splitting vertices with not coherent Wedge coordinates.
<H2> Parameters </h2>
No parameters.<br>
\section f230 Convert PerVertex UV into PerWedge UV 

Converts per Vertex Texture Coordinates to per Wedge Texture Coordinates. It does not merge superfluous vertices...
<H2> Parameters </h2>
No parameters.<br>
\section f231 Parametrization: Trivial Per-Triangle 

Builds a trivial triangle-by-triangle parametrization. <br> Two methods are provided, the first maps maps all triangles into equal sized triangles, while the second one adapt the size of the triangles in texture space to their original size.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Quads per line </TD> <TD><i> Indicates how many triangles have to be put on each line (every quad contains two triangles)
Leave 0 for automatic calculation -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Texture Dimension (px) </TD> <TD><i> Gives an indication on how big the texture is -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Inter-Triangle border (px) </TD> <TD><i> Specifies how many pixels to be left between triangles in parametrization domain -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Method </TD> <TD><i> Choose space optimizing to map smaller faces into smaller triangles in parametrizazion domain -- </i></TD> </TR>
</TABLE>

\section f232 Set Texture 

Set a texture associated with current mesh parametrization.<br>If the texture provided exists it will be simply associated to the current mesh else a dummy texture will be created and saved in the same directory.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> Texture file </TD> <TD><i> If the file exists it will be associated to the mesh else a dummy one will be created -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Texture Dimension (px) </TD> <TD><i> If the named texture doesn't exists the dummy one will be squared with this size -- </i></TD> </TR>
</TABLE>

\section f233 Parametrization: Flat Plane 

Builds a trivial flat-plane parametrization.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Projection plane </TD> <TD><i> Choose the projection plane -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Preserve Ratio </TD> <TD><i> If checked the resulting parametrization will preserve the original apsect ratio of the model otherwise it will fill up the whole 0..1 uv space -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Side Gutter </TD> <TD><i> Leave an empty space around the parametrization area of the specified size (in texture space); accepted range [0.0 - 0.5]. -- </i></TD> </TR>
</TABLE>

\section f234 Transfer: Vertex Color to Texture 

Fills the specified texture using per-vertex color data of the mesh.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c String  </TD> <TD> Texture file </TD> <TD><i> The texture file to be created -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Texture width (px) </TD> <TD><i> The texture width -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Texture height (px) </TD> <TD><i> The texture height -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Overwrite texture </TD> <TD><i> if current mesh has a texture will be overwritten (with provided texture dimension) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Assign texture </TD> <TD><i> assign the newly created texture -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Fill texture </TD> <TD><i> if enabled the unmapped texture space is colored using a pull push filling algorithm, if false is set to black -- </i></TD> </TR>
</TABLE>

\section f235 Transfer: Vertex Attributes to Texture (1 or 2 meshes) 

Transfer texture color, vertex color or normal from one mesh the texture of another mesh. This may be useful to restore detail lost in simplification, or resample a texture in a different parametrization.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Source Mesh </TD> <TD><i> The mesh that contains the source data that we want to transfer -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Target Mesh </TD> <TD><i> The mesh whose texture will be filled according to source mesh data -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Color Data Source </TD> <TD><i> Choose what attribute has to be transferred onto the target texture. You can choose bettween Per vertex attributes (clor,normal,quality) or to transfer color information from source mesh texture -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Max Dist Search </TD> <TD><i> Sample points for which we do not find anything within this distance are rejected and not considered for recovering data -- </i></TD> </TR>
<TR><TD> \c String  </TD> <TD> Texture file </TD> <TD><i> The texture file to be created -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Texture width (px) </TD> <TD><i> The texture width -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Texture height (px) </TD> <TD><i> The texture height -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Overwrite Target Mesh Texture </TD> <TD><i> if target mesh has a texture will be overwritten (with provided texture dimension) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Assign Texture </TD> <TD><i> assign the newly created texture to target mesh -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Fill texture </TD> <TD><i> if enabled the unmapped texture space is colored using a pull push filling algorithm, if false is set to black -- </i></TD> </TR>
</TABLE>

\section f236 Transfer: Texture to Vertex Color (1 or 2 meshes) 

Generates Vertex Color values picking color from a texture (same mesh or another mesh).
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Source Mesh </TD> <TD><i> The mesh with associated texture that we want to sample from -- </i></TD> </TR>
<TR><TD> \c Mesh  </TD> <TD> Target Mesh </TD> <TD><i> The mesh whose vertex color will be filled according to source mesh texture -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Max Dist Search </TD> <TD><i> Sample points for which we do not find anything within this distance are rejected and not considered for recovering color -- </i></TD> </TR>
</TABLE>

\section f237 Planar flipping optimization 

Mesh optimization by edge flipping, to improve local triangle quality
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Update selection </TD> <TD><i> Apply edge flip optimization on selected faces only -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Planar threshold (deg) </TD> <TD><i> angle threshold for planar faces (degrees) -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Planar metric </TD> <TD><i> <p style='white-space:pre'>Choose a metric to define the planar flip operation<br><br>Triangle quality based<br>1: minimum ratio height/edge among the edges<br>2: ratio between radii of incenter and circumcenter<br>3: 2*sqrt(a, b)/(a+b), a, b the eigenvalues of M^tM,<br>     M transform triangle into equilateral<br><br>Others<br>4: Fix the Delaunay condition between two faces<br>5: Do the flip to improve local topology<br> -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Post optimization relax iter </TD> <TD><i> number of a planar laplacian smooth iterations that have to be performed after every run -- </i></TD> </TR>
</TABLE>

\section f238 Curvature flipping optimization 

Mesh optimization by edge flipping, to improve local mesh curvature
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Update selection </TD> <TD><i> Apply edge flip optimization on selected faces only -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Angle Thr (deg) </TD> <TD><i> To avoid excessive flipping/swapping we consider only couple of faces with a significant diedral angle (e.g. greater than the indicated threshold).  -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Curvature metric </TD> <TD><i> <p style='white-space:pre'>Choose a metric to compute surface curvature on vertices<br>H = mean curv, K = gaussian curv, A = area per vertex<br><br>1: Mean curvature = H<br>2: Norm squared mean curvature = (H * H) / A<br>3: Absolute curvature:<br>     if(K >= 0) return 2 * H<br>     else return 2 * sqrt(H ^ 2 - A * K) -- </i></TD> </TR>
</TABLE>

\section f239 Laplacian Smooth (surface preserving) 

Laplacian smooth with limited surface modification: move each vertex in the average position of neighbors vertices, only if the new position still (almost) lies on original surface
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Update selection </TD> <TD><i> Apply laplacian smooth on selected faces only -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Max Normal Dev (deg) </TD> <TD><i> maximum mean normal angle displacement (degrees) from old to new faces -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Iterations </TD> <TD><i> number of laplacian smooth iterations in every run -- </i></TD> </TR>
</TABLE>

\section f240 Cut mesh along crease edges 

Cut the mesh along crease edges, duplicating the vertices as necessary. Crease (or sharp) edges are defined according to the variation of normal of the adjacent faces.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Crease Angle (degree) </TD> <TD><i> If the angle between the normals of two adjacent faces is <b>larger</b> that this threshold the edge is considered a creased and the mesh is cut along it. -- </i></TD> </TR>
</TABLE>

\section f241 Laplacian Smooth 

Laplacian smooth. Average each vertex position with weighted positions of neighbour vertices.<br><b>Laplacian Mesh Processing</b> by <i>Olga Sorkine</i>. EUROGRAPHICS 2005<br><a href='http://dx.doi.org/10.2312/egst.20051044'>doi:10.2312/egst.20051044</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Smoothing steps </TD> <TD><i> The number of times that the whole algorithm (normal smoothing + vertex fitting) is iterated. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> 1D Boundary Smoothing </TD> <TD><i> Smooth boundary edges only by themselves (e.g. the polyline forming the boundary of the mesh is independently smoothed). This can reduce the shrinking on the border but can have strange effects on very small boundaries. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Cotangent weighting </TD> <TD><i> Use cotangent weighting scheme for the averaging of the position. Otherwise the simpler umbrella scheme (1 if the edge is present) is used. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selection </TD> <TD><i> If checked the filter is performed only on the selected area -- </i></TD> </TR>
</TABLE>

\section f242 HC Laplacian Smooth 

HC Laplacian Smoothing. Extended version of Laplacian Smoothing based on the article: <br><b>Improved Laplacian Smoothing of Noisy Surface Meshes</b> by <i>Vollmer, Mencl and Müller</i>. EUROGRAPHICS Volume 18 (1999), Number 3, 131-138.<br><a href='https://doi.org/10.1111/1467-8659.00334'>doi:10.1111/1467-8659.00334</a>
<H2> Parameters </h2>
No parameters.<br>
\section f243 ScaleDependent Laplacian Smooth 

Scale Dependent Laplacian Smoothing, extended version of Laplacian Smoothing based on the Fujiwara extended umbrella operator.<br><b>Implicit Fairing of Irregular Meshes using Diffusion and Curvature Flow</b> by <i>Desbrun, Meyer, Schroeder and Barr</i>. SIGGRAPH 1999<br><a href='https://doi.org/10.1145/311535.311576'>doi:10.1145/311535.311576</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Smoothing steps </TD> <TD><i> The number of times that the whole algorithm (normal smoothing + vertex fitting) is iterated. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> delta </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selected faces </TD> <TD><i> If checked the filter is performed only on the selected faces -- </i></TD> </TR>
</TABLE>

\section f244 TwoStep Smooth 

Two Steps Smoothing, a feature preserving/enhancing fairing filter based on two stages:<ol><li>Normal Smoothing, where similar normals are averaged together.<li>Vertex reposition, where vertices are moved to fit on the new normals.</ol><b>A Comparison of Mesh Smoothing Methods</b> by <i>A. Belyaev and Y. Ohtake</i>. Proc. Israel-Korea Bi-National Conf. Geometric Modeling and Computer Graphics, pp. 83-87, 2003.<br><a href='https://www.researchgate.net/publication/47861030_A_comparison_of_mesh_smoothing_methods'>publication</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Smoothing steps </TD> <TD><i> The number of times that the whole algorithm (normal smoothing + vertex fitting) is iterated. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Feature Angle Threshold (deg) </TD> <TD><i> Specify a threshold angle (0..90) for features that you want to be preserved.<br>Features forming angles LARGER than the specified threshold will be preserved. <br> 0 -> no smoothing <br> 90 -> all faces will be smoothed -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Normal Smoothing steps </TD> <TD><i> Number of iterations of normal smoothing step. The larger the better and (the slower) -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Vertex Fitting steps </TD> <TD><i> Number of iterations of the vertex fitting procedure. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selected faces </TD> <TD><i> If checked the filter is performed only on the selected faces -- </i></TD> </TR>
</TABLE>

\section f245 Taubin Smooth 

The &lambda;-&mu; Taubin smoothing, combines two steps of low-pass filtering for each iteration. Based on the article:<br><b>A signal processing approach to fair surface design</b> by <i>Gabriel Taubin</i>, SIGGRAPH 1995<br><a href='https://doi.org/10.1145/218380.218473'>doi:10.1145/218380.218473</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Lambda </TD> <TD><i> The lambda parameter of the Taubin Smoothing algorithm -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> mu </TD> <TD><i> The mu parameter of the Taubin Smoothing algorithm -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Smoothing steps </TD> <TD><i> The number of times that the taubin smoothing is iterated. Usually it requires a larger number of iteration than the classical laplacian -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selected faces </TD> <TD><i> If checked the filter is performed only on the selected faces -- </i></TD> </TR>
</TABLE>

\section f246 Depth Smooth 

A laplacian smooth that is constrained to move vertices only in one given direction (usually the viewer direction).
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Smoothing steps </TD> <TD><i> The number of times that the whole algorithm (normal smoothing + vertex fitting) is iterated. -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Viewpoint </TD> <TD><i> The position of the view point that is used to get the constraint direction. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Strength </TD> <TD><i> How much smoothing is applied: 0 (no smooth) e 1 (full smooth) -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selection </TD> <TD><i> If checked the filter is performed only on the selected area -- </i></TD> </TR>
</TABLE>

\section f247 Directional Geom. Preserv. 

Store and Blend the current geometry with the result of another previous smoothing processing step. This is useful to limit the influence of any smoothing algorithm along the viewing direction. This is useful to cope with the biased distribution of measuring error in many scanning devices, because TOF scanners usually have very good <i>x,y</i>accuracy but suffer of greater depth errors.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Step: </TD> <TD><i> The purpose of this filter is to <b>constrain</b> any smoothing algorithm to moving vertices only along a give line of sight.<br> First you should store current vertex position, than after applying  one of the many smoothing algorithms you should re start this filter and blend the original positions with the smoothed results.<br>Given a view point  <i>vp</i> , the smoothed vertex position <i>vs</i> and the original position  <i>v</i>, The new vertex position is computed as the projection of  <i>vs</i> on the line  connecting  <i>v</i>  and <i>vp</i>. -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Viewpoint </TD> <TD><i> The position of the view point that is used to get the constraint direction. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Affect only selected faces </TD> <TD><i> If checked the filter is performed only on the selected faces -- </i></TD> </TR>
</TABLE>

\section f248 Smooth Vertex Quality 

Laplacian smooth of the <a href='https://stackoverflow.com/questions/58610746'>quality per vertex</a> values.
<H2> Parameters </h2>
No parameters.<br>
\section f249 Smooth Face Normals 

Laplacian smooth of the face normals, without touching the position of the vertices.
<H2> Parameters </h2>
No parameters.<br>
\section f250 UnSharp Mask Normals 

Unsharp mask filtering of the normals per face, putting in more evidence normal variations.<br><b>A simple normal enhancement technique for interactive non-photorealistic renderings</b> by <i>Cignoni, Scopigno and Tarini</i>, Comput Graph, 29 (1) (2005)<br><a href='https://doi.org/10.1016/j.cag.2004.11.012'>doi:10.1016/j.cag.2004.11.012</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Recompute Normals </TD> <TD><i> Recompute normals from scratch before the unsharp masking -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Unsharp Weight </TD> <TD><i> the unsharp weight <i>w<sub><big>u</big></sub></i> in the unsharp mask equation: <br> <i>w<sub><big>o</big></sub>orig + w<sub><big>u</big></sub> (orig - lowpass)<i><br> -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Original Weight </TD> <TD><i> How much the original signal is used, e.g. the weight <i>w<sub><big>o</big></sub></i> in the above unsharp mask equation.<br> Usually you should not need to change the default 1.0 value. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Smooth Iterations </TD> <TD><i> number of laplacian face smooth iterations in every run -- </i></TD> </TR>
</TABLE>

\section f251 UnSharp Mask Geometry 

Apply Unsharp filter to geometric shape, putting in more evidence ridges and valleys variations.<br><a href='https://en.wikipedia.org/wiki/Unsharp_masking'>Unsharp Masking</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Unsharp Weight </TD> <TD><i> the unsharp weight <i>w<sub><big>u</big></sub></i> in the unsharp mask equation: <br> <i>w<sub><big>o</big></sub>orig + w<sub><big>u</big></sub> (orig - lowpass)<i><br> -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Original Weight </TD> <TD><i> How much the original signal is used, e.g. the weight <i>w<sub><big>o</big></sub></i> in the above unsharp mask equation<br> Usually you should not need to change the default 1.0 value. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Smooth Iterations </TD> <TD><i> number of iterations of laplacian smooth in every run -- </i></TD> </TR>
</TABLE>

\section f252 UnSharp Mask Quality 

Apply Unsharp filter to values of <a href='https://stackoverflow.com/questions/58610746'>quality per vertex</a>.<br>See <a href='https://en.wikipedia.org/wiki/Unsharp_masking'>Unsharp Masking</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Unsharp Weight </TD> <TD><i> the unsharp weight <i>w<sub><big>u</big></sub></i> in the unsharp mask equation: <br> <i>w<sub><big>o</big></sub>orig + w<sub><big>u</big></sub> (orig - lowpass)<i><br> -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Original Weight </TD> <TD><i> How much the original signal is used, e.g. the weight <i>w<sub><big>o</big></sub></i> in the above unsharp mask equation<br> Usually you should not need to change the default 1.0 value. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Smooth Iterations </TD> <TD><i> number of iterations of laplacian smooth in every run -- </i></TD> </TR>
</TABLE>

\section f253 UnSharp Mask Color 

Apply Unsharp filter to the vertex color, putting in more evidence color variations.<br>See <a href='https://en.wikipedia.org/wiki/Unsharp_masking'>Unsharp Masking</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Float  </TD> <TD> Unsharp Weight </TD> <TD><i> the unsharp weight <i>w<sub><big>u</big></sub></i> in the unsharp mask equation: <br> <i>w<sub><big>o</big></sub>orig + w<sub><big>u</big></sub> (orig - lowpass)<i><br> -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Original Color Weight </TD> <TD><i> How much the original signal is used, e.g. the weight <i>w<sub><big>o</big></sub></i> in the above unsharp mask equation<br> Usually you should not need to change the default 1.0 value. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Smooth Iterations </TD> <TD><i> number of iterations of laplacian smooth in every run -- </i></TD> </TR>
</TABLE>

\section f254 Re-Compute Vertex Normals 

Recompute vertex normals according to four different schemes:<br>1) Simple (no weights) average of normals of the incident faces <br>2) Area weighted average of normals of the incident faces <br>3) Angle weighted sum of normals of the incident faces according to the article <b>[1]</b>. Probably this is the best all-purpose choice. It could slightly bias the result for degenerate, fat triangles.<br>4) Weighted sum of normals of the incident faces, as defined by article <b>[2]</b>. The weight for each wedge is the cross product of the two edges over the product of the square of the two edge lengths.According to the original article it is perfect only for spherical surface, but it should perform well also in practice.<br>[1]: <b>Computing Vertex Normals from Polygonal Facet</b> by <i>G Thurmer and CA Wuthrich</i>, JGT volume3, num 1. 1998<br><a href='https://doi.org/10.1080/10867651.1998.10487487'>doi:10.1080/10867651.1998.10487487</a><br>[2]: <b>Weights for Computing Vertex Normals from Facet Normals</b> by <i>Nelson Max</i>, JGT vol4, num 2. 1999<br><a href='https://doi.org/10.1080/10867651.1999.10487501'>doi:10.1080/10867651.1999.10487501</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Weighting Mode: </TD> <TD><i>  -- </i></TD> </TR>
</TABLE>

\section f255 Re-Compute Face Normals 

Recompute face normals as the normal of the plane of the face.<br>See <a href='https://math.stackexchange.com/questions/305642/'>How to find surface normal of a triangle</a>
<H2> Parameters </h2>
No parameters.<br>
\section f256 Re-Compute Per-Polygon Face Normals 

Recompute face normals as the average of the normals of the triangles that builds a polygon. Useful for showing uniformly shaded quad or polygonal meshes represented using <a href='https://stackoverflow.com/questions/59392193'>faux edges</a>.
<H2> Parameters </h2>
No parameters.<br>
\section f257 Normalize Face Normals 

Normalize Face Normal Lengths to unit vectors.
<H2> Parameters </h2>
No parameters.<br>
\section f258 Normalize Vertex Normals 

Normalize Vertex Normal Lengths to unit vectors.
<H2> Parameters </h2>
No parameters.<br>
\section f259 Vertex Linear Morphing 

Morph deformation of current mesh towards a target mesh with the same number of vertices and same vertex ordering. Each vertex of the source mesh is linearly interpolated towards the corresponding vertex on the target mesh using the formula:<p align='center'>result<sub><big>i</big></sub> = (1-&lambda;)*source<sub><big>i</big></sub> + &lambda;*target<sub><big>i</big></sub></p><b>Three-dimensional metamorphosis: a survey</b><br>by <i>F. Lazarus and A. Verroust</i>, Visual Computer, 1998<br><a href='https://doi.org/10.1007/s003710050149'>doi:10.1007/s003710050149</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Mesh  </TD> <TD> Target Mesh </TD> <TD><i> The mesh that is the morph target. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> % Morph </TD> <TD><i> The percent you want to morph towards (or away from) the target. <br>0 means current mesh <br>100 means targe mesh <br><0 and >100 linearly extrapolate between the two mesh <br> -- </i></TD> </TR>
</TABLE>

\section f260 Generate Scalar Harmonic Field 

Generates a scalar harmonic field over the mesh. Input scalar values must be assigned to two vertices as Dirichlet boundary conditions. Applying the filter, a discrete Laplace operator generates the harmonic field values for all the mesh vertices, which are stored in the <a href='https://stackoverflow.com/questions/58610746'>quality per vertex attribute</a> of the mesh.<br>For more details see:<b>Dynamic Harmonic Fields for Surface Processing</b> by <i>Kai Xua, Hao Zhang, Daniel Cohen-Or, Yueshan Xionga</i>. Computers & Graphics, 2009 <br><a href='https://doi.org/10.1016/j.cag.2009.03.022'>doi:10.1016/j.cag.2009.03.022</a>
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Point3f  </TD> <TD> Point 1 </TD> <TD><i> A vertex on the mesh that represent one harmonic field boundary condition. -- </i></TD> </TR>
<TR><TD> \c Point3f  </TD> <TD> Point 2 </TD> <TD><i> A vertex on the mesh that represent one harmonic field boundary condition. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> value for the 1st point </TD> <TD><i> Harmonic field value for the vertex. -- </i></TD> </TR>
<TR><TD> \c DynamicFloat  </TD> <TD> value for the 2nd point </TD> <TD><i> Harmonic field value for the vertex. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Colorize </TD> <TD><i> Colorize the mesh to provide an indication of the obtained harmonic field. -- </i></TD> </TR>
</TABLE>

\section f261 Voronoi Sampling 

Compute a sampling over a mesh and perform a Lloyd relaxation.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Int  </TD> <TD> Iteration </TD> <TD><i> number of iterations -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Sample Num. </TD> <TD><i> Number of samples -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Radius Variance </TD> <TD><i> The distance metric will vary along the surface between 1/x and x, linearly according to the scalar field specified by the quality. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Color Strategy </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Distance Type </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Preprocessing </TD> <TD><i>  -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Refinement Factor </TD> <TD><i> To ensure good convergence the mesh should be more complex than the voronoi partitioning. This number affect how much the mesh is refined according to the required number of samples. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Perturbation Probability </TD> <TD><i> To ensure good convergence the mesh should be more complex than the voronoi partitioning. This number affect how much the mesh is refined according to the required number of samples. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Perturbation Amount </TD> <TD><i> To ensure good convergence the mesh should be more complex than the voronoi partitioning. This number affect how much the mesh is refined according to the required number of samples. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Random seed </TD> <TD><i> To ensure repeatability you can specify the random seed used. If 0 the random seed is tied to the current clock. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Relax Type </TD> <TD><i> At each relaxation step we search for each voronoi region the new position of the seed. According to the classical LLoyd relaxation strategy it should have been placed onto the barycenter of the region. Over a surface we have two different strategies: <ul><li> Geodesic: the seed is placed onto the vertex that maximize the geodesic distance from the border of the region </li><li> Squared Distance: the seed is placed in the vertex that minimize the squared sum of the distances from all the pints of the region.</li><li> Restricted: the seed is placed in the barycenter of current voronoi region. Even if it is outside the surface. During the relaxation process the seed is free to move off the surface in a continuous way. Re-association to vertex is done at the end..</li></ul> -- </i></TD> </TR>
</TABLE>

\section f262 Volumetric Sampling 

Compute a volumetric sampling over a watertight mesh.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Surface Sampling Radius </TD> <TD><i> Surface Sampling is used only as an optimization. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Volume Sample Num. </TD> <TD><i> Number of volumetric samples scattered inside the mesh and used for choosing the voronoi seeds and performing the Lloyd relaxation for having a centroidal voronoi diagram. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Poisson Filtering </TD> <TD><i> If true the base montecarlo sampling of the volume is filtered to get a poisson disk volumetric distribution. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Poisson Radius </TD> <TD><i> Number of voxel per side in the volumetric representation. -- </i></TD> </TR>
</TABLE>

\section f263 Voronoi Scaffolding 

Compute a volumetric sampling over a watertight mesh.
<H2> Parameters </h2>
<TABLE>
<TR><TD> \c AbsPerc  </TD> <TD> Surface Sampling Radius </TD> <TD><i> Surface Sampling is used only as an optimization. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Volume Sample Num. </TD> <TD><i> Number of volumetric samples scattered inside the mesh and used for choosing the voronoi seeds and performing the Lloyd relaxation for having a centroidal voronoi diagram. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Volume Side Resolution </TD> <TD><i> Number of voxel per side in the volumetric representation. -- </i></TD> </TR>
<TR><TD> \c Float  </TD> <TD> Width of the entity (in voxel) </TD> <TD><i> Number of voxel per side in the volumetric representation. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Smooth Step </TD> <TD><i> Number of voxel per side in the volumetric representation. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Lloyd Relax Step </TD> <TD><i> Number of Lloyd relaxation step to get a better distribution of the voronoi seeds. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Add original surface </TD> <TD><i> Number of voxel per side in the volumetric representation. -- </i></TD> </TR>
<TR><TD> \c Enum  </TD> <TD> Voronoi Element </TD> <TD><i>  -- </i></TD> </TR>
</TABLE>

\section f264 Create Solid Wireframe 


<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Bool  </TD> <TD> Edge -> Cyl. </TD> <TD><i> If True all the edges are converted into cylinders. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Edge Cylinder Rad. </TD> <TD><i> The radius of the cylinder replacing each edge. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Vertex -> Cyl. </TD> <TD><i> If True all the vertices are converted into cylinders. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Vertex Cylinder Rad. </TD> <TD><i> The radius of the cylinder replacing each vertex. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Vertex -> Sph. </TD> <TD><i> If True all the vertices are converted into sphere. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Vertex Sphere Rad. </TD> <TD><i> The radius of the sphere replacing each vertex. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Face -> Prism </TD> <TD><i> If True all the faces are converted into prism. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Face Prism Height </TD> <TD><i> The Height of the prism that is substitued with each face. -- </i></TD> </TR>
<TR><TD> \c AbsPerc  </TD> <TD> Face Prism Inset </TD> <TD><i> The inset radius of each prism, e.g. how much it is moved toward the inside each vertex on the border of the prism. -- </i></TD> </TR>
<TR><TD> \c Bool  </TD> <TD> Ignore faux edges </TD> <TD><i> If true only the Non-Faux edges will be considered for conversion. -- </i></TD> </TR>
<TR><TD> \c Int  </TD> <TD> Cylinder Side </TD> <TD><i> Number of sides of the cylinder (both edge and vertex). -- </i></TD> </TR>
</TABLE>

\section f265 Cross Field Creation 


<H2> Parameters </h2>
<TABLE>
<TR><TD> \c Enum  </TD> <TD> Cross Type </TD> <TD><i>  -- </i></TD> </TR>
</TABLE>
*/